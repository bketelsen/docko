// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeJob = `-- name: CompleteJob :one
UPDATE jobs
SET status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

func (q *Queries) CompleteJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, completeJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const countFailedJobs = `-- name: CountFailedJobs :one
SELECT COUNT(*) FROM jobs WHERE status = 'failed'
`

func (q *Queries) CountFailedJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const dequeueJobs = `-- name: DequeueJobs :many
WITH next_jobs AS (
    SELECT id FROM jobs
    WHERE queue_name = $1
      AND (status = 'pending' OR (status = 'processing' AND visible_until < NOW()))
      AND scheduled_at <= NOW()
      AND attempt < max_attempts
    ORDER BY created_at
    LIMIT $2
    FOR UPDATE SKIP LOCKED
)
UPDATE jobs
SET status = 'processing',
    attempt = attempt + 1,
    started_at = NOW(),
    visible_until = NOW() + INTERVAL '5 minutes',
    updated_at = NOW()
FROM next_jobs
WHERE jobs.id = next_jobs.id
RETURNING jobs.id, jobs.queue_name, jobs.job_type, jobs.payload, jobs.status, jobs.attempt, jobs.max_attempts, jobs.scheduled_at, jobs.visible_until, jobs.started_at, jobs.completed_at, jobs.last_error, jobs.created_at, jobs.updated_at, jobs.current_step
`

type DequeueJobsParams struct {
	Column1 *string `json:"column_1"`
	Column2 *int64  `json:"column_2"`
}

func (q *Queries) DequeueJobs(ctx context.Context, arg DequeueJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, dequeueJobs, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dismissFailedJobsForQueue = `-- name: DismissFailedJobsForQueue :execrows
UPDATE jobs SET status = 'dismissed', updated_at = NOW()
WHERE queue_name = $1 AND status = 'failed'
`

func (q *Queries) DismissFailedJobsForQueue(ctx context.Context, queueName string) (int64, error) {
	result, err := q.db.Exec(ctx, dismissFailedJobsForQueue, queueName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dismissJob = `-- name: DismissJob :one
UPDATE jobs SET status = 'dismissed', updated_at = NOW()
WHERE id = $1 AND status = 'failed'
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

func (q *Queries) DismissJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, dismissJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const enqueueJob = `-- name: EnqueueJob :one
INSERT INTO jobs (queue_name, job_type, payload, max_attempts, scheduled_at)
VALUES ($1, $2, $3, COALESCE($4, 3), COALESCE($5, NOW()))
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

type EnqueueJobParams struct {
	QueueName string             `json:"queue_name"`
	JobType   string             `json:"job_type"`
	Payload   []byte             `json:"payload"`
	Column4   *int32             `json:"column_4"`
	Column5   pgtype.Timestamptz `json:"column_5"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, enqueueJob,
		arg.QueueName,
		arg.JobType,
		arg.Payload,
		arg.Column4,
		arg.Column5,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const failJob = `-- name: FailJob :one
UPDATE jobs
SET status = 'failed',
    last_error = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

type FailJobParams struct {
	ID        uuid.UUID `json:"id"`
	LastError *string   `json:"last_error"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, failJob, arg.ID, arg.LastError)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const getFailedJobs = `-- name: GetFailedJobs :many
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs WHERE queue_name = $1 AND status = 'failed' ORDER BY updated_at DESC LIMIT $2
`

type GetFailedJobsParams struct {
	QueueName string `json:"queue_name"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) GetFailedJobs(ctx context.Context, arg GetFailedJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, getFailedJobs, arg.QueueName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedJobsForQueue = `-- name: GetFailedJobsForQueue :many
SELECT
    j.id, j.queue_name, j.job_type, j.payload, j.status, j.attempt, j.max_attempts, j.scheduled_at, j.visible_until, j.started_at, j.completed_at, j.last_error, j.created_at, j.updated_at, j.current_step,
    d.id as document_id,
    d.original_filename as document_name
FROM jobs j
LEFT JOIN LATERAL (
    SELECT id, original_filename
    FROM documents
    WHERE id = (j.payload->>'document_id')::uuid
) d ON true
WHERE j.queue_name = $1 AND j.status = 'failed'
ORDER BY j.updated_at DESC
LIMIT $2 OFFSET $3
`

type GetFailedJobsForQueueParams struct {
	QueueName string `json:"queue_name"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

type GetFailedJobsForQueueRow struct {
	ID           uuid.UUID          `json:"id"`
	QueueName    string             `json:"queue_name"`
	JobType      string             `json:"job_type"`
	Payload      []byte             `json:"payload"`
	Status       JobStatus          `json:"status"`
	Attempt      int32              `json:"attempt"`
	MaxAttempts  int32              `json:"max_attempts"`
	ScheduledAt  time.Time          `json:"scheduled_at"`
	VisibleUntil pgtype.Timestamptz `json:"visible_until"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	LastError    *string            `json:"last_error"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
	CurrentStep  *string            `json:"current_step"`
	DocumentID   uuid.UUID          `json:"document_id"`
	DocumentName string             `json:"document_name"`
}

func (q *Queries) GetFailedJobsForQueue(ctx context.Context, arg GetFailedJobsForQueueParams) ([]GetFailedJobsForQueueRow, error) {
	rows, err := q.db.Query(ctx, getFailedJobsForQueue, arg.QueueName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFailedJobsForQueueRow{}
	for rows.Next() {
		var i GetFailedJobsForQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
			&i.DocumentID,
			&i.DocumentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJob = `-- name: GetJob :one
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const getPendingJobCount = `-- name: GetPendingJobCount :one
SELECT COUNT(*) FROM jobs WHERE queue_name = $1 AND status = 'pending'
`

func (q *Queries) GetPendingJobCount(ctx context.Context, queueName string) (int64, error) {
	row := q.db.QueryRow(ctx, getPendingJobCount, queueName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueueNames = `-- name: GetQueueNames :many
SELECT DISTINCT queue_name FROM jobs ORDER BY queue_name
`

func (q *Queries) GetQueueNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getQueueNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var queue_name string
		if err := rows.Scan(&queue_name); err != nil {
			return nil, err
		}
		items = append(items, queue_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueStats = `-- name: GetQueueStats :many
SELECT
    queue_name,
    status,
    COUNT(*) as count
FROM jobs
GROUP BY queue_name, status
ORDER BY queue_name, status
`

type GetQueueStatsRow struct {
	QueueName string    `json:"queue_name"`
	Status    JobStatus `json:"status"`
	Count     int64     `json:"count"`
}

func (q *Queries) GetQueueStats(ctx context.Context) ([]GetQueueStatsRow, error) {
	rows, err := q.db.Query(ctx, getQueueStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQueueStatsRow{}
	for rows.Next() {
		var i GetQueueStatsRow
		if err := rows.Scan(&i.QueueName, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentCompletedJobsForQueue = `-- name: GetRecentCompletedJobsForQueue :many
SELECT
    j.id, j.queue_name, j.job_type, j.payload, j.status, j.attempt, j.max_attempts, j.scheduled_at, j.visible_until, j.started_at, j.completed_at, j.last_error, j.created_at, j.updated_at, j.current_step,
    d.id as document_id,
    d.original_filename as document_name
FROM jobs j
LEFT JOIN LATERAL (
    SELECT id, original_filename
    FROM documents
    WHERE id = (j.payload->>'document_id')::uuid
) d ON true
WHERE j.queue_name = $1
    AND j.status = 'completed'
    AND j.completed_at > NOW() - INTERVAL '24 hours'
ORDER BY j.completed_at DESC
LIMIT $2 OFFSET $3
`

type GetRecentCompletedJobsForQueueParams struct {
	QueueName string `json:"queue_name"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

type GetRecentCompletedJobsForQueueRow struct {
	ID           uuid.UUID          `json:"id"`
	QueueName    string             `json:"queue_name"`
	JobType      string             `json:"job_type"`
	Payload      []byte             `json:"payload"`
	Status       JobStatus          `json:"status"`
	Attempt      int32              `json:"attempt"`
	MaxAttempts  int32              `json:"max_attempts"`
	ScheduledAt  time.Time          `json:"scheduled_at"`
	VisibleUntil pgtype.Timestamptz `json:"visible_until"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	LastError    *string            `json:"last_error"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
	CurrentStep  *string            `json:"current_step"`
	DocumentID   uuid.UUID          `json:"document_id"`
	DocumentName string             `json:"document_name"`
}

func (q *Queries) GetRecentCompletedJobsForQueue(ctx context.Context, arg GetRecentCompletedJobsForQueueParams) ([]GetRecentCompletedJobsForQueueRow, error) {
	rows, err := q.db.Query(ctx, getRecentCompletedJobsForQueue, arg.QueueName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentCompletedJobsForQueueRow{}
	for rows.Next() {
		var i GetRecentCompletedJobsForQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
			&i.DocumentID,
			&i.DocumentName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentJobs = `-- name: GetRecentJobs :many
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentJobs(ctx context.Context, limit int64) ([]Job, error) {
	rows, err := q.db.Query(ctx, getRecentJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedJobs = `-- name: ListFailedJobs :many
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs
WHERE status = 'failed'
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type ListFailedJobsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListFailedJobs(ctx context.Context, arg ListFailedJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listFailedJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobsByQueue = `-- name: ListJobsByQueue :many
SELECT id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step FROM jobs
WHERE queue_name = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByQueueParams struct {
	QueueName string `json:"queue_name"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListJobsByQueue(ctx context.Context, arg ListJobsByQueueParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, listJobsByQueue, arg.QueueName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.QueueName,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempt,
			&i.MaxAttempts,
			&i.ScheduledAt,
			&i.VisibleUntil,
			&i.StartedAt,
			&i.CompletedAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetAllFailedJobs = `-- name: ResetAllFailedJobs :exec
UPDATE jobs SET
    status = 'pending',
    attempt = 0,
    scheduled_at = NOW(),
    visible_until = NULL,
    last_error = NULL,
    updated_at = NOW()
WHERE status = 'failed'
`

func (q *Queries) ResetAllFailedJobs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllFailedJobs)
	return err
}

const resetFailedJobsForQueue = `-- name: ResetFailedJobsForQueue :execrows
UPDATE jobs SET
    status = 'pending',
    attempt = 0,
    scheduled_at = NOW(),
    visible_until = NULL,
    last_error = NULL,
    updated_at = NOW()
WHERE queue_name = $1 AND status = 'failed'
`

func (q *Queries) ResetFailedJobsForQueue(ctx context.Context, queueName string) (int64, error) {
	result, err := q.db.Exec(ctx, resetFailedJobsForQueue, queueName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const resetJobForRetry = `-- name: ResetJobForRetry :one
UPDATE jobs SET
    status = 'pending',
    attempt = 0,
    scheduled_at = NOW(),
    visible_until = NULL,
    last_error = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

func (q *Queries) ResetJobForRetry(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, resetJobForRetry, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const retryJob = `-- name: RetryJob :one
UPDATE jobs
SET status = 'pending',
    scheduled_at = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, queue_name, job_type, payload, status, attempt, max_attempts, scheduled_at, visible_until, started_at, completed_at, last_error, created_at, updated_at, current_step
`

type RetryJobParams struct {
	ID          uuid.UUID          `json:"id"`
	ScheduledAt pgtype.Timestamptz `json:"scheduled_at"`
}

func (q *Queries) RetryJob(ctx context.Context, arg RetryJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, retryJob, arg.ID, arg.ScheduledAt)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.QueueName,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempt,
		&i.MaxAttempts,
		&i.ScheduledAt,
		&i.VisibleUntil,
		&i.StartedAt,
		&i.CompletedAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CurrentStep,
	)
	return i, err
}

const updateJobStep = `-- name: UpdateJobStep :exec
UPDATE jobs
SET current_step = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateJobStepParams struct {
	ID          uuid.UUID `json:"id"`
	CurrentStep *string   `json:"current_step"`
}

func (q *Queries) UpdateJobStep(ctx context.Context, arg UpdateJobStepParams) error {
	_, err := q.db.Exec(ctx, updateJobStep, arg.ID, arg.CurrentStep)
	return err
}
