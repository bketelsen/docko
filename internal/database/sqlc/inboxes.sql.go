// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inboxes.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createInbox = `-- name: CreateInbox :one
INSERT INTO inboxes (path, name, error_path, duplicate_action, enabled)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at
`

type CreateInboxParams struct {
	Path            string          `json:"path"`
	Name            string          `json:"name"`
	ErrorPath       *string         `json:"error_path"`
	DuplicateAction DuplicateAction `json:"duplicate_action"`
	Enabled         bool            `json:"enabled"`
}

func (q *Queries) CreateInbox(ctx context.Context, arg CreateInboxParams) (Inbox, error) {
	row := q.db.QueryRow(ctx, createInbox,
		arg.Path,
		arg.Name,
		arg.ErrorPath,
		arg.DuplicateAction,
		arg.Enabled,
	)
	var i Inbox
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Enabled,
		&i.ErrorPath,
		&i.DuplicateAction,
		&i.LastScanAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInboxEvent = `-- name: CreateInboxEvent :one
INSERT INTO inbox_events (inbox_id, filename, action, document_id, error_message)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, inbox_id, filename, action, document_id, error_message, created_at
`

type CreateInboxEventParams struct {
	InboxID      uuid.UUID   `json:"inbox_id"`
	Filename     string      `json:"filename"`
	Action       string      `json:"action"`
	DocumentID   pgtype.UUID `json:"document_id"`
	ErrorMessage *string     `json:"error_message"`
}

func (q *Queries) CreateInboxEvent(ctx context.Context, arg CreateInboxEventParams) (InboxEvent, error) {
	row := q.db.QueryRow(ctx, createInboxEvent,
		arg.InboxID,
		arg.Filename,
		arg.Action,
		arg.DocumentID,
		arg.ErrorMessage,
	)
	var i InboxEvent
	err := row.Scan(
		&i.ID,
		&i.InboxID,
		&i.Filename,
		&i.Action,
		&i.DocumentID,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInbox = `-- name: DeleteInbox :exec
DELETE FROM inboxes WHERE id = $1
`

func (q *Queries) DeleteInbox(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInbox, id)
	return err
}

const getInbox = `-- name: GetInbox :one
SELECT id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at FROM inboxes WHERE id = $1
`

func (q *Queries) GetInbox(ctx context.Context, id uuid.UUID) (Inbox, error) {
	row := q.db.QueryRow(ctx, getInbox, id)
	var i Inbox
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Enabled,
		&i.ErrorPath,
		&i.DuplicateAction,
		&i.LastScanAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInboxByPath = `-- name: GetInboxByPath :one
SELECT id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at FROM inboxes WHERE path = $1
`

func (q *Queries) GetInboxByPath(ctx context.Context, path string) (Inbox, error) {
	row := q.db.QueryRow(ctx, getInboxByPath, path)
	var i Inbox
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Enabled,
		&i.ErrorPath,
		&i.DuplicateAction,
		&i.LastScanAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEnabledInboxes = `-- name: ListEnabledInboxes :many
SELECT id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at FROM inboxes WHERE enabled = true ORDER BY created_at ASC
`

func (q *Queries) ListEnabledInboxes(ctx context.Context) ([]Inbox, error) {
	rows, err := q.db.Query(ctx, listEnabledInboxes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inbox{}
	for rows.Next() {
		var i Inbox
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.Enabled,
			&i.ErrorPath,
			&i.DuplicateAction,
			&i.LastScanAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInboxEvents = `-- name: ListInboxEvents :many
SELECT id, inbox_id, filename, action, document_id, error_message, created_at FROM inbox_events
WHERE inbox_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListInboxEventsParams struct {
	InboxID uuid.UUID `json:"inbox_id"`
	Limit   int64     `json:"limit"`
}

func (q *Queries) ListInboxEvents(ctx context.Context, arg ListInboxEventsParams) ([]InboxEvent, error) {
	rows, err := q.db.Query(ctx, listInboxEvents, arg.InboxID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InboxEvent{}
	for rows.Next() {
		var i InboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.InboxID,
			&i.Filename,
			&i.Action,
			&i.DocumentID,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInboxes = `-- name: ListInboxes :many
SELECT id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at FROM inboxes ORDER BY created_at ASC
`

func (q *Queries) ListInboxes(ctx context.Context) ([]Inbox, error) {
	rows, err := q.db.Query(ctx, listInboxes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inbox{}
	for rows.Next() {
		var i Inbox
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Name,
			&i.Enabled,
			&i.ErrorPath,
			&i.DuplicateAction,
			&i.LastScanAt,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentInboxEvents = `-- name: ListRecentInboxEvents :many
SELECT ie.id, ie.inbox_id, ie.filename, ie.action, ie.document_id, ie.error_message, ie.created_at, i.name as inbox_name
FROM inbox_events ie
JOIN inboxes i ON ie.inbox_id = i.id
ORDER BY ie.created_at DESC
LIMIT $1
`

type ListRecentInboxEventsRow struct {
	ID           uuid.UUID   `json:"id"`
	InboxID      uuid.UUID   `json:"inbox_id"`
	Filename     string      `json:"filename"`
	Action       string      `json:"action"`
	DocumentID   pgtype.UUID `json:"document_id"`
	ErrorMessage *string     `json:"error_message"`
	CreatedAt    time.Time   `json:"created_at"`
	InboxName    string      `json:"inbox_name"`
}

func (q *Queries) ListRecentInboxEvents(ctx context.Context, limit int64) ([]ListRecentInboxEventsRow, error) {
	rows, err := q.db.Query(ctx, listRecentInboxEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentInboxEventsRow{}
	for rows.Next() {
		var i ListRecentInboxEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.InboxID,
			&i.Filename,
			&i.Action,
			&i.DocumentID,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.InboxName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInbox = `-- name: UpdateInbox :one
UPDATE inboxes
SET name = $2, path = $3, error_path = $4, duplicate_action = $5, enabled = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, path, name, enabled, error_path, duplicate_action, last_scan_at, last_error, created_at, updated_at
`

type UpdateInboxParams struct {
	ID              uuid.UUID       `json:"id"`
	Name            string          `json:"name"`
	Path            string          `json:"path"`
	ErrorPath       *string         `json:"error_path"`
	DuplicateAction DuplicateAction `json:"duplicate_action"`
	Enabled         bool            `json:"enabled"`
}

func (q *Queries) UpdateInbox(ctx context.Context, arg UpdateInboxParams) (Inbox, error) {
	row := q.db.QueryRow(ctx, updateInbox,
		arg.ID,
		arg.Name,
		arg.Path,
		arg.ErrorPath,
		arg.DuplicateAction,
		arg.Enabled,
	)
	var i Inbox
	err := row.Scan(
		&i.ID,
		&i.Path,
		&i.Name,
		&i.Enabled,
		&i.ErrorPath,
		&i.DuplicateAction,
		&i.LastScanAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInboxStatus = `-- name: UpdateInboxStatus :exec
UPDATE inboxes
SET last_scan_at = $2, last_error = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateInboxStatusParams struct {
	ID         uuid.UUID          `json:"id"`
	LastScanAt pgtype.Timestamptz `json:"last_scan_at"`
	LastError  *string            `json:"last_error"`
}

func (q *Queries) UpdateInboxStatus(ctx context.Context, arg UpdateInboxStatusParams) error {
	_, err := q.db.Exec(ctx, updateInboxStatus, arg.ID, arg.LastScanAt, arg.LastError)
	return err
}
