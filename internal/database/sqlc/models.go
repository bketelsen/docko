// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type DuplicateAction string

const (
	DuplicateActionDelete DuplicateAction = "delete"
	DuplicateActionRename DuplicateAction = "rename"
	DuplicateActionSkip   DuplicateAction = "skip"
)

func (e *DuplicateAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DuplicateAction(s)
	case string:
		*e = DuplicateAction(s)
	default:
		return fmt.Errorf("unsupported scan type for DuplicateAction: %T", src)
	}
	return nil
}

type NullDuplicateAction struct {
	DuplicateAction DuplicateAction `json:"duplicate_action"`
	Valid           bool            `json:"valid"` // Valid is true if DuplicateAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDuplicateAction) Scan(value interface{}) error {
	if value == nil {
		ns.DuplicateAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DuplicateAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDuplicateAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DuplicateAction), nil
}

type JobStatus string

const (
	JobStatusPending    JobStatus = "pending"
	JobStatusProcessing JobStatus = "processing"
	JobStatusCompleted  JobStatus = "completed"
	JobStatusFailed     JobStatus = "failed"
	JobStatusDismissed  JobStatus = "dismissed"
)

func (e *JobStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = JobStatus(s)
	case string:
		*e = JobStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for JobStatus: %T", src)
	}
	return nil
}

type NullJobStatus struct {
	JobStatus JobStatus `json:"job_status"`
	Valid     bool      `json:"valid"` // Valid is true if JobStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullJobStatus) Scan(value interface{}) error {
	if value == nil {
		ns.JobStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.JobStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullJobStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.JobStatus), nil
}

type NetworkProtocol string

const (
	NetworkProtocolSmb NetworkProtocol = "smb"
	NetworkProtocolNfs NetworkProtocol = "nfs"
)

func (e *NetworkProtocol) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NetworkProtocol(s)
	case string:
		*e = NetworkProtocol(s)
	default:
		return fmt.Errorf("unsupported scan type for NetworkProtocol: %T", src)
	}
	return nil
}

type NullNetworkProtocol struct {
	NetworkProtocol NetworkProtocol `json:"network_protocol"`
	Valid           bool            `json:"valid"` // Valid is true if NetworkProtocol is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNetworkProtocol) Scan(value interface{}) error {
	if value == nil {
		ns.NetworkProtocol, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NetworkProtocol.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNetworkProtocol) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NetworkProtocol), nil
}

type PostImportAction string

const (
	PostImportActionLeave  PostImportAction = "leave"
	PostImportActionDelete PostImportAction = "delete"
	PostImportActionMove   PostImportAction = "move"
)

func (e *PostImportAction) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PostImportAction(s)
	case string:
		*e = PostImportAction(s)
	default:
		return fmt.Errorf("unsupported scan type for PostImportAction: %T", src)
	}
	return nil
}

type NullPostImportAction struct {
	PostImportAction PostImportAction `json:"post_import_action"`
	Valid            bool             `json:"valid"` // Valid is true if PostImportAction is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPostImportAction) Scan(value interface{}) error {
	if value == nil {
		ns.PostImportAction, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PostImportAction.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPostImportAction) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PostImportAction), nil
}

type ProcessingStatus string

const (
	ProcessingStatusPending    ProcessingStatus = "pending"
	ProcessingStatusProcessing ProcessingStatus = "processing"
	ProcessingStatusCompleted  ProcessingStatus = "completed"
	ProcessingStatusFailed     ProcessingStatus = "failed"
)

func (e *ProcessingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProcessingStatus(s)
	case string:
		*e = ProcessingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProcessingStatus: %T", src)
	}
	return nil
}

type NullProcessingStatus struct {
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	Valid            bool             `json:"valid"` // Valid is true if ProcessingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProcessingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProcessingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProcessingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProcessingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProcessingStatus), nil
}

type SuggestionStatus string

const (
	SuggestionStatusPending     SuggestionStatus = "pending"
	SuggestionStatusAccepted    SuggestionStatus = "accepted"
	SuggestionStatusRejected    SuggestionStatus = "rejected"
	SuggestionStatusAutoApplied SuggestionStatus = "auto_applied"
)

func (e *SuggestionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SuggestionStatus(s)
	case string:
		*e = SuggestionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SuggestionStatus: %T", src)
	}
	return nil
}

type NullSuggestionStatus struct {
	SuggestionStatus SuggestionStatus `json:"suggestion_status"`
	Valid            bool             `json:"valid"` // Valid is true if SuggestionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSuggestionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SuggestionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SuggestionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSuggestionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SuggestionStatus), nil
}

type SuggestionType string

const (
	SuggestionTypeTag           SuggestionType = "tag"
	SuggestionTypeCorrespondent SuggestionType = "correspondent"
)

func (e *SuggestionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SuggestionType(s)
	case string:
		*e = SuggestionType(s)
	default:
		return fmt.Errorf("unsupported scan type for SuggestionType: %T", src)
	}
	return nil
}

type NullSuggestionType struct {
	SuggestionType SuggestionType `json:"suggestion_type"`
	Valid          bool           `json:"valid"` // Valid is true if SuggestionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSuggestionType) Scan(value interface{}) error {
	if value == nil {
		ns.SuggestionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SuggestionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSuggestionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SuggestionType), nil
}

type AdminSession struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	TokenHash string             `json:"token_hash"`
	ExpiresAt time.Time          `json:"expires_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type AdminUser struct {
	ID           uuid.UUID          `json:"id"`
	Username     string             `json:"username"`
	PasswordHash string             `json:"password_hash"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

type AiSetting struct {
	ID                 int32          `json:"id"`
	PreferredProvider  *string        `json:"preferred_provider"`
	MaxPages           int32          `json:"max_pages"`
	AutoProcess        bool           `json:"auto_process"`
	AutoApplyThreshold pgtype.Numeric `json:"auto_apply_threshold"`
	ReviewThreshold    pgtype.Numeric `json:"review_threshold"`
	UpdatedAt          time.Time      `json:"updated_at"`
	MinWordCount       int32          `json:"min_word_count"`
}

type AiSuggestion struct {
	ID             uuid.UUID          `json:"id"`
	DocumentID     uuid.UUID          `json:"document_id"`
	JobID          pgtype.UUID        `json:"job_id"`
	SuggestionType SuggestionType     `json:"suggestion_type"`
	Value          string             `json:"value"`
	Confidence     pgtype.Numeric     `json:"confidence"`
	Reasoning      *string            `json:"reasoning"`
	IsNew          bool               `json:"is_new"`
	Status         SuggestionStatus   `json:"status"`
	CreatedAt      time.Time          `json:"created_at"`
	ResolvedAt     pgtype.Timestamptz `json:"resolved_at"`
	ResolvedBy     *string            `json:"resolved_by"`
}

type AiUsage struct {
	ID           uuid.UUID   `json:"id"`
	DocumentID   uuid.UUID   `json:"document_id"`
	JobID        pgtype.UUID `json:"job_id"`
	Provider     string      `json:"provider"`
	Model        string      `json:"model"`
	InputTokens  int32       `json:"input_tokens"`
	OutputTokens int32       `json:"output_tokens"`
	CreatedAt    time.Time   `json:"created_at"`
}

type Correspondent struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	CreatedAt time.Time `json:"created_at"`
	Notes     *string   `json:"notes"`
}

type Document struct {
	ID                 uuid.UUID          `json:"id"`
	OriginalFilename   string             `json:"original_filename"`
	ContentHash        string             `json:"content_hash"`
	FileSize           int64              `json:"file_size"`
	PageCount          *int32             `json:"page_count"`
	PdfTitle           *string            `json:"pdf_title"`
	PdfAuthor          *string            `json:"pdf_author"`
	PdfCreatedAt       pgtype.Timestamptz `json:"pdf_created_at"`
	DocumentDate       time.Time          `json:"document_date"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	ProcessingStatus   ProcessingStatus   `json:"processing_status"`
	TextContent        *string            `json:"text_content"`
	ThumbnailGenerated bool               `json:"thumbnail_generated"`
	ProcessingError    *string            `json:"processing_error"`
	ProcessedAt        pgtype.Timestamptz `json:"processed_at"`
	SearchVector       interface{}        `json:"search_vector"`
}

type DocumentCorrespondent struct {
	DocumentID      uuid.UUID `json:"document_id"`
	CorrespondentID uuid.UUID `json:"correspondent_id"`
}

type DocumentEvent struct {
	ID           uuid.UUID `json:"id"`
	DocumentID   uuid.UUID `json:"document_id"`
	EventType    string    `json:"event_type"`
	Payload      []byte    `json:"payload"`
	ErrorMessage *string   `json:"error_message"`
	DurationMs   *int32    `json:"duration_ms"`
	CreatedAt    time.Time `json:"created_at"`
}

type DocumentTag struct {
	DocumentID uuid.UUID `json:"document_id"`
	TagID      uuid.UUID `json:"tag_id"`
}

type Example struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

type Inbox struct {
	ID              uuid.UUID          `json:"id"`
	Path            string             `json:"path"`
	Name            string             `json:"name"`
	Enabled         bool               `json:"enabled"`
	ErrorPath       *string            `json:"error_path"`
	DuplicateAction DuplicateAction    `json:"duplicate_action"`
	LastScanAt      pgtype.Timestamptz `json:"last_scan_at"`
	LastError       *string            `json:"last_error"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

type InboxEvent struct {
	ID           uuid.UUID   `json:"id"`
	InboxID      uuid.UUID   `json:"inbox_id"`
	Filename     string      `json:"filename"`
	Action       string      `json:"action"`
	DocumentID   pgtype.UUID `json:"document_id"`
	ErrorMessage *string     `json:"error_message"`
	CreatedAt    time.Time   `json:"created_at"`
}

type Job struct {
	ID           uuid.UUID          `json:"id"`
	QueueName    string             `json:"queue_name"`
	JobType      string             `json:"job_type"`
	Payload      []byte             `json:"payload"`
	Status       JobStatus          `json:"status"`
	Attempt      int32              `json:"attempt"`
	MaxAttempts  int32              `json:"max_attempts"`
	ScheduledAt  time.Time          `json:"scheduled_at"`
	VisibleUntil pgtype.Timestamptz `json:"visible_until"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	LastError    *string            `json:"last_error"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
	CurrentStep  *string            `json:"current_step"`
}

type NetworkSource struct {
	ID                  uuid.UUID          `json:"id"`
	Name                string             `json:"name"`
	Protocol            NetworkProtocol    `json:"protocol"`
	Host                string             `json:"host"`
	SharePath           string             `json:"share_path"`
	Username            *string            `json:"username"`
	PasswordEncrypted   *string            `json:"password_encrypted"`
	Enabled             bool               `json:"enabled"`
	ContinuousSync      bool               `json:"continuous_sync"`
	PostImportAction    PostImportAction   `json:"post_import_action"`
	MoveSubfolder       *string            `json:"move_subfolder"`
	DuplicateAction     DuplicateAction    `json:"duplicate_action"`
	BatchSize           int32              `json:"batch_size"`
	ConnectionState     *string            `json:"connection_state"`
	ConsecutiveFailures int32              `json:"consecutive_failures"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	LastError           *string            `json:"last_error"`
	FilesImported       int32              `json:"files_imported"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
}

type NetworkSourceEvent struct {
	ID           uuid.UUID   `json:"id"`
	SourceID     uuid.UUID   `json:"source_id"`
	Filename     string      `json:"filename"`
	RemotePath   string      `json:"remote_path"`
	Action       string      `json:"action"`
	DocumentID   pgtype.UUID `json:"document_id"`
	ErrorMessage *string     `json:"error_message"`
	CreatedAt    time.Time   `json:"created_at"`
}

type Tag struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Color     *string   `json:"color"`
	CreatedAt time.Time `json:"created_at"`
}
