// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: correspondents.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const appendCorrespondentNotes = `-- name: AppendCorrespondentNotes :one
UPDATE correspondents
SET notes = CASE
    WHEN notes IS NULL OR notes = '' THEN $2
    ELSE notes || E'\n---\n' || $2
END
WHERE id = $1
RETURNING id, name, created_at, notes
`

type AppendCorrespondentNotesParams struct {
	ID    uuid.UUID `json:"id"`
	Notes *string   `json:"notes"`
}

func (q *Queries) AppendCorrespondentNotes(ctx context.Context, arg AppendCorrespondentNotesParams) (Correspondent, error) {
	row := q.db.QueryRow(ctx, appendCorrespondentNotes, arg.ID, arg.Notes)
	var i Correspondent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.Notes,
	)
	return i, err
}

const createCorrespondent = `-- name: CreateCorrespondent :one
INSERT INTO correspondents (name, notes)
VALUES ($1, $2)
RETURNING id, name, notes, created_at
`

type CreateCorrespondentParams struct {
	Name  string  `json:"name"`
	Notes *string `json:"notes"`
}

type CreateCorrespondentRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Notes     *string   `json:"notes"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateCorrespondent(ctx context.Context, arg CreateCorrespondentParams) (CreateCorrespondentRow, error) {
	row := q.db.QueryRow(ctx, createCorrespondent, arg.Name, arg.Notes)
	var i CreateCorrespondentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCorrespondent = `-- name: DeleteCorrespondent :exec
DELETE FROM correspondents WHERE id = $1
`

func (q *Queries) DeleteCorrespondent(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCorrespondent, id)
	return err
}

const deleteCorrespondentsByIds = `-- name: DeleteCorrespondentsByIds :exec
DELETE FROM correspondents WHERE id = ANY($1::uuid[])
`

func (q *Queries) DeleteCorrespondentsByIds(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCorrespondentsByIds, dollar_1)
	return err
}

const getCorrespondent = `-- name: GetCorrespondent :one
SELECT id, name, notes, created_at FROM correspondents WHERE id = $1
`

type GetCorrespondentRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Notes     *string   `json:"notes"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) GetCorrespondent(ctx context.Context, id uuid.UUID) (GetCorrespondentRow, error) {
	row := q.db.QueryRow(ctx, getCorrespondent, id)
	var i GetCorrespondentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getCorrespondentsNotes = `-- name: GetCorrespondentsNotes :many
SELECT id, name, notes FROM correspondents
WHERE id = ANY($1::uuid[]) AND notes IS NOT NULL AND notes != ''
`

type GetCorrespondentsNotesRow struct {
	ID    uuid.UUID `json:"id"`
	Name  string    `json:"name"`
	Notes *string   `json:"notes"`
}

func (q *Queries) GetCorrespondentsNotes(ctx context.Context, dollar_1 []uuid.UUID) ([]GetCorrespondentsNotesRow, error) {
	rows, err := q.db.Query(ctx, getCorrespondentsNotes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCorrespondentsNotesRow{}
	for rows.Next() {
		var i GetCorrespondentsNotesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Notes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentCorrespondent = `-- name: GetDocumentCorrespondent :one
SELECT c.id, c.name, c.created_at, c.notes FROM correspondents c
INNER JOIN document_correspondents dc ON dc.correspondent_id = c.id
WHERE dc.document_id = $1
`

func (q *Queries) GetDocumentCorrespondent(ctx context.Context, documentID uuid.UUID) (Correspondent, error) {
	row := q.db.QueryRow(ctx, getDocumentCorrespondent, documentID)
	var i Correspondent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.Notes,
	)
	return i, err
}

const listCorrespondentsWithCounts = `-- name: ListCorrespondentsWithCounts :many
SELECT c.id, c.name, c.notes, c.created_at, COUNT(dc.document_id)::int AS document_count
FROM correspondents c
LEFT JOIN document_correspondents dc ON dc.correspondent_id = c.id
GROUP BY c.id
ORDER BY c.name
`

type ListCorrespondentsWithCountsRow struct {
	ID            uuid.UUID `json:"id"`
	Name          string    `json:"name"`
	Notes         *string   `json:"notes"`
	CreatedAt     time.Time `json:"created_at"`
	DocumentCount int32     `json:"document_count"`
}

func (q *Queries) ListCorrespondentsWithCounts(ctx context.Context) ([]ListCorrespondentsWithCountsRow, error) {
	rows, err := q.db.Query(ctx, listCorrespondentsWithCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCorrespondentsWithCountsRow{}
	for rows.Next() {
		var i ListCorrespondentsWithCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Notes,
			&i.CreatedAt,
			&i.DocumentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeCorrespondentsUpdateDocs = `-- name: MergeCorrespondentsUpdateDocs :exec
UPDATE document_correspondents
SET correspondent_id = $1
WHERE correspondent_id = ANY($2::uuid[])
`

type MergeCorrespondentsUpdateDocsParams struct {
	CorrespondentID uuid.UUID   `json:"correspondent_id"`
	Column2         []uuid.UUID `json:"column_2"`
}

func (q *Queries) MergeCorrespondentsUpdateDocs(ctx context.Context, arg MergeCorrespondentsUpdateDocsParams) error {
	_, err := q.db.Exec(ctx, mergeCorrespondentsUpdateDocs, arg.CorrespondentID, arg.Column2)
	return err
}

const removeDocumentCorrespondent = `-- name: RemoveDocumentCorrespondent :exec
DELETE FROM document_correspondents
WHERE document_id = $1
`

func (q *Queries) RemoveDocumentCorrespondent(ctx context.Context, documentID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeDocumentCorrespondent, documentID)
	return err
}

const searchCorrespondents = `-- name: SearchCorrespondents :many
SELECT id, name, notes, created_at FROM correspondents
WHERE name ILIKE $1
ORDER BY name
LIMIT 10
`

type SearchCorrespondentsRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Notes     *string   `json:"notes"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) SearchCorrespondents(ctx context.Context, name string) ([]SearchCorrespondentsRow, error) {
	rows, err := q.db.Query(ctx, searchCorrespondents, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchCorrespondentsRow{}
	for rows.Next() {
		var i SearchCorrespondentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCorrespondentsWithLimit = `-- name: SearchCorrespondentsWithLimit :many
SELECT id, name, created_at, notes FROM correspondents
WHERE name ILIKE $1
ORDER BY name
LIMIT 10
`

func (q *Queries) SearchCorrespondentsWithLimit(ctx context.Context, name string) ([]Correspondent, error) {
	rows, err := q.db.Query(ctx, searchCorrespondentsWithLimit, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Correspondent{}
	for rows.Next() {
		var i Correspondent
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDocumentCorrespondent = `-- name: SetDocumentCorrespondent :exec
INSERT INTO document_correspondents (document_id, correspondent_id)
VALUES ($1, $2)
ON CONFLICT (document_id) DO UPDATE SET correspondent_id = $2
`

type SetDocumentCorrespondentParams struct {
	DocumentID      uuid.UUID `json:"document_id"`
	CorrespondentID uuid.UUID `json:"correspondent_id"`
}

func (q *Queries) SetDocumentCorrespondent(ctx context.Context, arg SetDocumentCorrespondentParams) error {
	_, err := q.db.Exec(ctx, setDocumentCorrespondent, arg.DocumentID, arg.CorrespondentID)
	return err
}

const updateCorrespondent = `-- name: UpdateCorrespondent :one
UPDATE correspondents SET name = $1, notes = $2 WHERE id = $3
RETURNING id, name, notes, created_at
`

type UpdateCorrespondentParams struct {
	Name  string    `json:"name"`
	Notes *string   `json:"notes"`
	ID    uuid.UUID `json:"id"`
}

type UpdateCorrespondentRow struct {
	ID        uuid.UUID `json:"id"`
	Name      string    `json:"name"`
	Notes     *string   `json:"notes"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) UpdateCorrespondent(ctx context.Context, arg UpdateCorrespondentParams) (UpdateCorrespondentRow, error) {
	row := q.db.QueryRow(ctx, updateCorrespondent, arg.Name, arg.Notes, arg.ID)
	var i UpdateCorrespondentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}
