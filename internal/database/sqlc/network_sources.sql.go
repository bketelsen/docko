// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: network_sources.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createNetworkSource = `-- name: CreateNetworkSource :one
INSERT INTO network_sources (
    name, protocol, host, share_path, username, password_encrypted,
    enabled, continuous_sync, post_import_action, move_subfolder,
    duplicate_action, batch_size
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at
`

type CreateNetworkSourceParams struct {
	Name              string           `json:"name"`
	Protocol          NetworkProtocol  `json:"protocol"`
	Host              string           `json:"host"`
	SharePath         string           `json:"share_path"`
	Username          *string          `json:"username"`
	PasswordEncrypted *string          `json:"password_encrypted"`
	Enabled           bool             `json:"enabled"`
	ContinuousSync    bool             `json:"continuous_sync"`
	PostImportAction  PostImportAction `json:"post_import_action"`
	MoveSubfolder     *string          `json:"move_subfolder"`
	DuplicateAction   DuplicateAction  `json:"duplicate_action"`
	BatchSize         int32            `json:"batch_size"`
}

func (q *Queries) CreateNetworkSource(ctx context.Context, arg CreateNetworkSourceParams) (NetworkSource, error) {
	row := q.db.QueryRow(ctx, createNetworkSource,
		arg.Name,
		arg.Protocol,
		arg.Host,
		arg.SharePath,
		arg.Username,
		arg.PasswordEncrypted,
		arg.Enabled,
		arg.ContinuousSync,
		arg.PostImportAction,
		arg.MoveSubfolder,
		arg.DuplicateAction,
		arg.BatchSize,
	)
	var i NetworkSource
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Protocol,
		&i.Host,
		&i.SharePath,
		&i.Username,
		&i.PasswordEncrypted,
		&i.Enabled,
		&i.ContinuousSync,
		&i.PostImportAction,
		&i.MoveSubfolder,
		&i.DuplicateAction,
		&i.BatchSize,
		&i.ConnectionState,
		&i.ConsecutiveFailures,
		&i.LastSyncAt,
		&i.LastError,
		&i.FilesImported,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNetworkSourceEvent = `-- name: CreateNetworkSourceEvent :one
INSERT INTO network_source_events (source_id, filename, remote_path, action, document_id, error_message)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, source_id, filename, remote_path, action, document_id, error_message, created_at
`

type CreateNetworkSourceEventParams struct {
	SourceID     uuid.UUID   `json:"source_id"`
	Filename     string      `json:"filename"`
	RemotePath   string      `json:"remote_path"`
	Action       string      `json:"action"`
	DocumentID   pgtype.UUID `json:"document_id"`
	ErrorMessage *string     `json:"error_message"`
}

func (q *Queries) CreateNetworkSourceEvent(ctx context.Context, arg CreateNetworkSourceEventParams) (NetworkSourceEvent, error) {
	row := q.db.QueryRow(ctx, createNetworkSourceEvent,
		arg.SourceID,
		arg.Filename,
		arg.RemotePath,
		arg.Action,
		arg.DocumentID,
		arg.ErrorMessage,
	)
	var i NetworkSourceEvent
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Filename,
		&i.RemotePath,
		&i.Action,
		&i.DocumentID,
		&i.ErrorMessage,
		&i.CreatedAt,
	)
	return i, err
}

const deleteNetworkSource = `-- name: DeleteNetworkSource :exec
DELETE FROM network_sources WHERE id = $1
`

func (q *Queries) DeleteNetworkSource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteNetworkSource, id)
	return err
}

const disableNetworkSource = `-- name: DisableNetworkSource :exec
UPDATE network_sources SET enabled = false, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DisableNetworkSource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, disableNetworkSource, id)
	return err
}

const getNetworkSource = `-- name: GetNetworkSource :one
SELECT id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at FROM network_sources WHERE id = $1
`

func (q *Queries) GetNetworkSource(ctx context.Context, id uuid.UUID) (NetworkSource, error) {
	row := q.db.QueryRow(ctx, getNetworkSource, id)
	var i NetworkSource
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Protocol,
		&i.Host,
		&i.SharePath,
		&i.Username,
		&i.PasswordEncrypted,
		&i.Enabled,
		&i.ContinuousSync,
		&i.PostImportAction,
		&i.MoveSubfolder,
		&i.DuplicateAction,
		&i.BatchSize,
		&i.ConnectionState,
		&i.ConsecutiveFailures,
		&i.LastSyncAt,
		&i.LastError,
		&i.FilesImported,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementConsecutiveFailures = `-- name: IncrementConsecutiveFailures :one
UPDATE network_sources SET
    consecutive_failures = consecutive_failures + 1, updated_at = NOW()
WHERE id = $1
RETURNING consecutive_failures
`

func (q *Queries) IncrementConsecutiveFailures(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementConsecutiveFailures, id)
	var consecutive_failures int32
	err := row.Scan(&consecutive_failures)
	return consecutive_failures, err
}

const incrementFilesImported = `-- name: IncrementFilesImported :exec
UPDATE network_sources SET
    files_imported = files_imported + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementFilesImported(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementFilesImported, id)
	return err
}

const listContinuousSyncSources = `-- name: ListContinuousSyncSources :many
SELECT id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at FROM network_sources
WHERE enabled = true AND continuous_sync = true
ORDER BY created_at ASC
`

func (q *Queries) ListContinuousSyncSources(ctx context.Context) ([]NetworkSource, error) {
	rows, err := q.db.Query(ctx, listContinuousSyncSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkSource{}
	for rows.Next() {
		var i NetworkSource
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Protocol,
			&i.Host,
			&i.SharePath,
			&i.Username,
			&i.PasswordEncrypted,
			&i.Enabled,
			&i.ContinuousSync,
			&i.PostImportAction,
			&i.MoveSubfolder,
			&i.DuplicateAction,
			&i.BatchSize,
			&i.ConnectionState,
			&i.ConsecutiveFailures,
			&i.LastSyncAt,
			&i.LastError,
			&i.FilesImported,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledNetworkSources = `-- name: ListEnabledNetworkSources :many
SELECT id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at FROM network_sources WHERE enabled = true ORDER BY created_at ASC
`

func (q *Queries) ListEnabledNetworkSources(ctx context.Context) ([]NetworkSource, error) {
	rows, err := q.db.Query(ctx, listEnabledNetworkSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkSource{}
	for rows.Next() {
		var i NetworkSource
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Protocol,
			&i.Host,
			&i.SharePath,
			&i.Username,
			&i.PasswordEncrypted,
			&i.Enabled,
			&i.ContinuousSync,
			&i.PostImportAction,
			&i.MoveSubfolder,
			&i.DuplicateAction,
			&i.BatchSize,
			&i.ConnectionState,
			&i.ConsecutiveFailures,
			&i.LastSyncAt,
			&i.LastError,
			&i.FilesImported,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNetworkSourceEvents = `-- name: ListNetworkSourceEvents :many
SELECT id, source_id, filename, remote_path, action, document_id, error_message, created_at FROM network_source_events
WHERE source_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListNetworkSourceEventsParams struct {
	SourceID uuid.UUID `json:"source_id"`
	Limit    int64     `json:"limit"`
}

func (q *Queries) ListNetworkSourceEvents(ctx context.Context, arg ListNetworkSourceEventsParams) ([]NetworkSourceEvent, error) {
	rows, err := q.db.Query(ctx, listNetworkSourceEvents, arg.SourceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkSourceEvent{}
	for rows.Next() {
		var i NetworkSourceEvent
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Filename,
			&i.RemotePath,
			&i.Action,
			&i.DocumentID,
			&i.ErrorMessage,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNetworkSources = `-- name: ListNetworkSources :many
SELECT id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at FROM network_sources ORDER BY created_at ASC
`

func (q *Queries) ListNetworkSources(ctx context.Context) ([]NetworkSource, error) {
	rows, err := q.db.Query(ctx, listNetworkSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkSource{}
	for rows.Next() {
		var i NetworkSource
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Protocol,
			&i.Host,
			&i.SharePath,
			&i.Username,
			&i.PasswordEncrypted,
			&i.Enabled,
			&i.ContinuousSync,
			&i.PostImportAction,
			&i.MoveSubfolder,
			&i.DuplicateAction,
			&i.BatchSize,
			&i.ConnectionState,
			&i.ConsecutiveFailures,
			&i.LastSyncAt,
			&i.LastError,
			&i.FilesImported,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetConsecutiveFailures = `-- name: ResetConsecutiveFailures :exec
UPDATE network_sources SET
    consecutive_failures = 0, connection_state = 'connected', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResetConsecutiveFailures(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetConsecutiveFailures, id)
	return err
}

const updateNetworkSource = `-- name: UpdateNetworkSource :one
UPDATE network_sources SET
    name = $2, protocol = $3, host = $4, share_path = $5,
    username = $6, password_encrypted = $7, enabled = $8,
    continuous_sync = $9, post_import_action = $10, move_subfolder = $11,
    duplicate_action = $12, batch_size = $13, updated_at = NOW()
WHERE id = $1
RETURNING id, name, protocol, host, share_path, username, password_encrypted, enabled, continuous_sync, post_import_action, move_subfolder, duplicate_action, batch_size, connection_state, consecutive_failures, last_sync_at, last_error, files_imported, created_at, updated_at
`

type UpdateNetworkSourceParams struct {
	ID                uuid.UUID        `json:"id"`
	Name              string           `json:"name"`
	Protocol          NetworkProtocol  `json:"protocol"`
	Host              string           `json:"host"`
	SharePath         string           `json:"share_path"`
	Username          *string          `json:"username"`
	PasswordEncrypted *string          `json:"password_encrypted"`
	Enabled           bool             `json:"enabled"`
	ContinuousSync    bool             `json:"continuous_sync"`
	PostImportAction  PostImportAction `json:"post_import_action"`
	MoveSubfolder     *string          `json:"move_subfolder"`
	DuplicateAction   DuplicateAction  `json:"duplicate_action"`
	BatchSize         int32            `json:"batch_size"`
}

func (q *Queries) UpdateNetworkSource(ctx context.Context, arg UpdateNetworkSourceParams) (NetworkSource, error) {
	row := q.db.QueryRow(ctx, updateNetworkSource,
		arg.ID,
		arg.Name,
		arg.Protocol,
		arg.Host,
		arg.SharePath,
		arg.Username,
		arg.PasswordEncrypted,
		arg.Enabled,
		arg.ContinuousSync,
		arg.PostImportAction,
		arg.MoveSubfolder,
		arg.DuplicateAction,
		arg.BatchSize,
	)
	var i NetworkSource
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Protocol,
		&i.Host,
		&i.SharePath,
		&i.Username,
		&i.PasswordEncrypted,
		&i.Enabled,
		&i.ContinuousSync,
		&i.PostImportAction,
		&i.MoveSubfolder,
		&i.DuplicateAction,
		&i.BatchSize,
		&i.ConnectionState,
		&i.ConsecutiveFailures,
		&i.LastSyncAt,
		&i.LastError,
		&i.FilesImported,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNetworkSourceStatus = `-- name: UpdateNetworkSourceStatus :exec
UPDATE network_sources SET
    connection_state = $2, consecutive_failures = $3,
    last_sync_at = $4, last_error = $5, updated_at = NOW()
WHERE id = $1
`

type UpdateNetworkSourceStatusParams struct {
	ID                  uuid.UUID          `json:"id"`
	ConnectionState     *string            `json:"connection_state"`
	ConsecutiveFailures int32              `json:"consecutive_failures"`
	LastSyncAt          pgtype.Timestamptz `json:"last_sync_at"`
	LastError           *string            `json:"last_error"`
}

func (q *Queries) UpdateNetworkSourceStatus(ctx context.Context, arg UpdateNetworkSourceStatusParams) error {
	_, err := q.db.Exec(ctx, updateNetworkSourceStatus,
		arg.ID,
		arg.ConnectionState,
		arg.ConsecutiveFailures,
		arg.LastSyncAt,
		arg.LastError,
	)
	return err
}
