// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ai.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acceptSuggestion = `-- name: AcceptSuggestion :one
UPDATE ai_suggestions SET
    status = 'accepted',
    resolved_at = NOW(),
    resolved_by = 'user'
WHERE id = $1
RETURNING id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by
`

func (q *Queries) AcceptSuggestion(ctx context.Context, id uuid.UUID) (AiSuggestion, error) {
	row := q.db.QueryRow(ctx, acceptSuggestion, id)
	var i AiSuggestion
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.SuggestionType,
		&i.Value,
		&i.Confidence,
		&i.Reasoning,
		&i.IsNew,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const autoApplySuggestion = `-- name: AutoApplySuggestion :one
UPDATE ai_suggestions SET
    status = 'auto_applied',
    resolved_at = NOW(),
    resolved_by = 'auto'
WHERE id = $1
RETURNING id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by
`

func (q *Queries) AutoApplySuggestion(ctx context.Context, id uuid.UUID) (AiSuggestion, error) {
	row := q.db.QueryRow(ctx, autoApplySuggestion, id)
	var i AiSuggestion
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.SuggestionType,
		&i.Value,
		&i.Confidence,
		&i.Reasoning,
		&i.IsNew,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const countPendingSuggestions = `-- name: CountPendingSuggestions :one
SELECT COUNT(*) FROM ai_suggestions WHERE status = 'pending'
`

func (q *Queries) CountPendingSuggestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingSuggestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAISuggestion = `-- name: CreateAISuggestion :one

INSERT INTO ai_suggestions (
    document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, resolved_at, resolved_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by
`

type CreateAISuggestionParams struct {
	DocumentID     uuid.UUID          `json:"document_id"`
	JobID          pgtype.UUID        `json:"job_id"`
	SuggestionType SuggestionType     `json:"suggestion_type"`
	Value          string             `json:"value"`
	Confidence     pgtype.Numeric     `json:"confidence"`
	Reasoning      *string            `json:"reasoning"`
	IsNew          bool               `json:"is_new"`
	Status         SuggestionStatus   `json:"status"`
	ResolvedAt     pgtype.Timestamptz `json:"resolved_at"`
	ResolvedBy     *string            `json:"resolved_by"`
}

// AI Suggestions
func (q *Queries) CreateAISuggestion(ctx context.Context, arg CreateAISuggestionParams) (AiSuggestion, error) {
	row := q.db.QueryRow(ctx, createAISuggestion,
		arg.DocumentID,
		arg.JobID,
		arg.SuggestionType,
		arg.Value,
		arg.Confidence,
		arg.Reasoning,
		arg.IsNew,
		arg.Status,
		arg.ResolvedAt,
		arg.ResolvedBy,
	)
	var i AiSuggestion
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.SuggestionType,
		&i.Value,
		&i.Confidence,
		&i.Reasoning,
		&i.IsNew,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const createAIUsage = `-- name: CreateAIUsage :one

INSERT INTO ai_usage (document_id, job_id, provider, model, input_tokens, output_tokens)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, document_id, job_id, provider, model, input_tokens, output_tokens, created_at
`

type CreateAIUsageParams struct {
	DocumentID   uuid.UUID   `json:"document_id"`
	JobID        pgtype.UUID `json:"job_id"`
	Provider     string      `json:"provider"`
	Model        string      `json:"model"`
	InputTokens  int32       `json:"input_tokens"`
	OutputTokens int32       `json:"output_tokens"`
}

// AI Usage tracking
func (q *Queries) CreateAIUsage(ctx context.Context, arg CreateAIUsageParams) (AiUsage, error) {
	row := q.db.QueryRow(ctx, createAIUsage,
		arg.DocumentID,
		arg.JobID,
		arg.Provider,
		arg.Model,
		arg.InputTokens,
		arg.OutputTokens,
	)
	var i AiUsage
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.Provider,
		&i.Model,
		&i.InputTokens,
		&i.OutputTokens,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDocumentSuggestions = `-- name: DeleteDocumentSuggestions :exec
DELETE FROM ai_suggestions WHERE document_id = $1
`

func (q *Queries) DeleteDocumentSuggestions(ctx context.Context, documentID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteDocumentSuggestions, documentID)
	return err
}

const getAISettings = `-- name: GetAISettings :one

SELECT id, preferred_provider, max_pages, auto_process, auto_apply_threshold, review_threshold, updated_at, min_word_count FROM ai_settings WHERE id = 1
`

// AI Settings (singleton)
func (q *Queries) GetAISettings(ctx context.Context) (AiSetting, error) {
	row := q.db.QueryRow(ctx, getAISettings)
	var i AiSetting
	err := row.Scan(
		&i.ID,
		&i.PreferredProvider,
		&i.MaxPages,
		&i.AutoProcess,
		&i.AutoApplyThreshold,
		&i.ReviewThreshold,
		&i.UpdatedAt,
		&i.MinWordCount,
	)
	return i, err
}

const getAISuggestion = `-- name: GetAISuggestion :one
SELECT id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by FROM ai_suggestions WHERE id = $1
`

func (q *Queries) GetAISuggestion(ctx context.Context, id uuid.UUID) (AiSuggestion, error) {
	row := q.db.QueryRow(ctx, getAISuggestion, id)
	var i AiSuggestion
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.SuggestionType,
		&i.Value,
		&i.Confidence,
		&i.Reasoning,
		&i.IsNew,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const getAIUsageStats = `-- name: GetAIUsageStats :one
SELECT
    COUNT(*) as documents_processed,
    COALESCE(SUM(input_tokens), 0) as total_input_tokens,
    COALESCE(SUM(output_tokens), 0) as total_output_tokens
FROM ai_usage
`

type GetAIUsageStatsRow struct {
	DocumentsProcessed int64  `json:"documents_processed"`
	TotalInputTokens   *int64 `json:"total_input_tokens"`
	TotalOutputTokens  *int64 `json:"total_output_tokens"`
}

func (q *Queries) GetAIUsageStats(ctx context.Context) (GetAIUsageStatsRow, error) {
	row := q.db.QueryRow(ctx, getAIUsageStats)
	var i GetAIUsageStatsRow
	err := row.Scan(&i.DocumentsProcessed, &i.TotalInputTokens, &i.TotalOutputTokens)
	return i, err
}

const getAIUsageStatsByProvider = `-- name: GetAIUsageStatsByProvider :many
SELECT
    provider,
    COUNT(*) as request_count,
    COALESCE(SUM(input_tokens), 0) as total_input_tokens,
    COALESCE(SUM(output_tokens), 0) as total_output_tokens
FROM ai_usage
GROUP BY provider
ORDER BY request_count DESC
`

type GetAIUsageStatsByProviderRow struct {
	Provider          string `json:"provider"`
	RequestCount      int64  `json:"request_count"`
	TotalInputTokens  *int64 `json:"total_input_tokens"`
	TotalOutputTokens *int64 `json:"total_output_tokens"`
}

func (q *Queries) GetAIUsageStatsByProvider(ctx context.Context) ([]GetAIUsageStatsByProviderRow, error) {
	rows, err := q.db.Query(ctx, getAIUsageStatsByProvider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAIUsageStatsByProviderRow{}
	for rows.Next() {
		var i GetAIUsageStatsByProviderRow
		if err := rows.Scan(
			&i.Provider,
			&i.RequestCount,
			&i.TotalInputTokens,
			&i.TotalOutputTokens,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAIUsage = `-- name: GetRecentAIUsage :many
SELECT id, document_id, job_id, provider, model, input_tokens, output_tokens, created_at FROM ai_usage
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) GetRecentAIUsage(ctx context.Context, limit int64) ([]AiUsage, error) {
	rows, err := q.db.Query(ctx, getRecentAIUsage, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AiUsage{}
	for rows.Next() {
		var i AiUsage
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.JobID,
			&i.Provider,
			&i.Model,
			&i.InputTokens,
			&i.OutputTokens,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentSuggestions = `-- name: ListDocumentSuggestions :many
SELECT id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by FROM ai_suggestions
WHERE document_id = $1
ORDER BY confidence DESC, created_at DESC
`

func (q *Queries) ListDocumentSuggestions(ctx context.Context, documentID uuid.UUID) ([]AiSuggestion, error) {
	rows, err := q.db.Query(ctx, listDocumentSuggestions, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AiSuggestion{}
	for rows.Next() {
		var i AiSuggestion
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.JobID,
			&i.SuggestionType,
			&i.Value,
			&i.Confidence,
			&i.Reasoning,
			&i.IsNew,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingSuggestions = `-- name: ListPendingSuggestions :many
SELECT s.id, s.document_id, s.job_id, s.suggestion_type, s.value, s.confidence, s.reasoning, s.is_new, s.status, s.created_at, s.resolved_at, s.resolved_by, d.original_filename
FROM ai_suggestions s
JOIN documents d ON s.document_id = d.id
WHERE s.status = 'pending'
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type ListPendingSuggestionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPendingSuggestionsRow struct {
	ID               uuid.UUID          `json:"id"`
	DocumentID       uuid.UUID          `json:"document_id"`
	JobID            pgtype.UUID        `json:"job_id"`
	SuggestionType   SuggestionType     `json:"suggestion_type"`
	Value            string             `json:"value"`
	Confidence       pgtype.Numeric     `json:"confidence"`
	Reasoning        *string            `json:"reasoning"`
	IsNew            bool               `json:"is_new"`
	Status           SuggestionStatus   `json:"status"`
	CreatedAt        time.Time          `json:"created_at"`
	ResolvedAt       pgtype.Timestamptz `json:"resolved_at"`
	ResolvedBy       *string            `json:"resolved_by"`
	OriginalFilename string             `json:"original_filename"`
}

func (q *Queries) ListPendingSuggestions(ctx context.Context, arg ListPendingSuggestionsParams) ([]ListPendingSuggestionsRow, error) {
	rows, err := q.db.Query(ctx, listPendingSuggestions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingSuggestionsRow{}
	for rows.Next() {
		var i ListPendingSuggestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.JobID,
			&i.SuggestionType,
			&i.Value,
			&i.Confidence,
			&i.Reasoning,
			&i.IsNew,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.OriginalFilename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingSuggestionsForDocument = `-- name: ListPendingSuggestionsForDocument :many
SELECT id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by FROM ai_suggestions
WHERE document_id = $1 AND status = 'pending'
ORDER BY confidence DESC
LIMIT 5
`

func (q *Queries) ListPendingSuggestionsForDocument(ctx context.Context, documentID uuid.UUID) ([]AiSuggestion, error) {
	rows, err := q.db.Query(ctx, listPendingSuggestionsForDocument, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AiSuggestion{}
	for rows.Next() {
		var i AiSuggestion
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.JobID,
			&i.SuggestionType,
			&i.Value,
			&i.Confidence,
			&i.Reasoning,
			&i.IsNew,
			&i.Status,
			&i.CreatedAt,
			&i.ResolvedAt,
			&i.ResolvedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectSuggestion = `-- name: RejectSuggestion :one
UPDATE ai_suggestions SET
    status = 'rejected',
    resolved_at = NOW(),
    resolved_by = 'user'
WHERE id = $1
RETURNING id, document_id, job_id, suggestion_type, value, confidence, reasoning, is_new, status, created_at, resolved_at, resolved_by
`

func (q *Queries) RejectSuggestion(ctx context.Context, id uuid.UUID) (AiSuggestion, error) {
	row := q.db.QueryRow(ctx, rejectSuggestion, id)
	var i AiSuggestion
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.JobID,
		&i.SuggestionType,
		&i.Value,
		&i.Confidence,
		&i.Reasoning,
		&i.IsNew,
		&i.Status,
		&i.CreatedAt,
		&i.ResolvedAt,
		&i.ResolvedBy,
	)
	return i, err
}

const updateAISettings = `-- name: UpdateAISettings :one
UPDATE ai_settings SET
    preferred_provider = $1,
    max_pages = $2,
    auto_process = $3,
    auto_apply_threshold = $4,
    review_threshold = $5,
    min_word_count = $6,
    updated_at = NOW()
WHERE id = 1
RETURNING id, preferred_provider, max_pages, auto_process, auto_apply_threshold, review_threshold, updated_at, min_word_count
`

type UpdateAISettingsParams struct {
	PreferredProvider  *string        `json:"preferred_provider"`
	MaxPages           int32          `json:"max_pages"`
	AutoProcess        bool           `json:"auto_process"`
	AutoApplyThreshold pgtype.Numeric `json:"auto_apply_threshold"`
	ReviewThreshold    pgtype.Numeric `json:"review_threshold"`
	MinWordCount       int32          `json:"min_word_count"`
}

func (q *Queries) UpdateAISettings(ctx context.Context, arg UpdateAISettingsParams) (AiSetting, error) {
	row := q.db.QueryRow(ctx, updateAISettings,
		arg.PreferredProvider,
		arg.MaxPages,
		arg.AutoProcess,
		arg.AutoApplyThreshold,
		arg.ReviewThreshold,
		arg.MinWordCount,
	)
	var i AiSetting
	err := row.Scan(
		&i.ID,
		&i.PreferredProvider,
		&i.MaxPages,
		&i.AutoProcess,
		&i.AutoApplyThreshold,
		&i.ReviewThreshold,
		&i.UpdatedAt,
		&i.MinWordCount,
	)
	return i, err
}
