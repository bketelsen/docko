package partials

import "docko/internal/database/sqlc"

// TagPicker renders a full tag picker with current tags and search input
templ TagPicker(documentID string, currentTags []sqlc.Tag) {
	<div class="tag-picker">
		// Display current tags as removable badges
		@DocumentTagsList(documentID, currentTags)
		// Search input
		<div class="relative mt-2">
			<input
				type="search"
				name="q"
				placeholder="Add tag..."
				class="w-full px-3 py-1.5 text-sm border border-input rounded-md bg-background focus:outline-none focus:ring-2 focus:ring-ring"
				hx-get={ "/documents/" + documentID + "/tags/search" }
				hx-trigger="input changed delay:300ms, focus"
				hx-target={ "#tag-search-" + documentID }
				autocomplete="off"
			/>
			<div
				id={ "tag-search-" + documentID }
				class="absolute z-10 w-full mt-1 bg-background border border-border rounded-md shadow-lg empty:hidden"
			>
				// Search results populated by HTMX
			</div>
		</div>
	</div>
}

// InlineTagPicker renders a compact tag picker for document list view
templ InlineTagPicker(documentID string, currentTags []sqlc.Tag) {
	<div id={ "inline-picker-" + documentID } class="inline-tag-picker">
		// Current tags display
		<div class="flex flex-wrap items-center gap-1">
			for _, tag := range currentTags {
				@TagBadgeSmall(documentID, tag, true)
			}
			// Add button with popup
			<div class="relative inline-block">
				<button
					type="button"
					class="inline-flex items-center justify-center w-5 h-5 text-xs border border-dashed border-muted-foreground/50 rounded text-muted-foreground hover:border-primary hover:text-primary transition-colors"
					title="Add tag"
					onclick={ toggleInlineSearch(documentID) }
				>
					<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
					</svg>
				</button>
				// Dropdown search (hidden by default)
				<div
					id={ "inline-dropdown-" + documentID }
					class="hidden absolute z-20 left-0 top-6 w-48 bg-background border border-border rounded-md shadow-lg"
				>
					<input
						type="search"
						name="q"
						placeholder="Search tags..."
						class="w-full px-2 py-1 text-xs border-b border-border bg-background focus:outline-none"
						hx-get={ "/documents/" + documentID + "/tags/search?inline=1" }
						hx-trigger="input changed delay:300ms, focus"
						hx-target={ "#inline-tag-search-" + documentID }
						autocomplete="off"
					/>
					<div
						id={ "inline-tag-search-" + documentID }
						class="max-h-48 overflow-y-auto empty:hidden"
					>
						// Search results populated by HTMX
					</div>
				</div>
			</div>
		</div>
	</div>
}

script toggleInlineSearch(documentID string) {
	const dropdown = document.getElementById('inline-dropdown-' + documentID);
	if (dropdown) {
		dropdown.classList.toggle('hidden');
		const input = dropdown.querySelector('input');
		if (input && !dropdown.classList.contains('hidden')) {
			input.focus();
		}
	}
	// Close on click outside
	const closeHandler = (e) => {
		if (!dropdown.contains(e.target) && !e.target.closest('button')) {
			dropdown.classList.add('hidden');
			document.removeEventListener('click', closeHandler);
		}
	};
	setTimeout(() => document.addEventListener('click', closeHandler), 0);
}

// DocumentTagsList renders the list of tags for HTMX swap after add/remove
templ DocumentTagsList(documentID string, tags []sqlc.Tag) {
	<div id={ "doc-" + documentID + "-tags" } class="flex flex-wrap gap-1">
		for _, tag := range tags {
			@TagBadge(documentID, tag, true)
		}
		if len(tags) == 0 {
			<span class="text-sm text-muted-foreground">No tags</span>
		}
	</div>
}

// TagBadge renders a tag badge with optional remove button
templ TagBadge(documentID string, tag sqlc.Tag, removable bool) {
	<span class={ "inline-flex items-center gap-1 px-2 py-0.5 text-xs font-medium rounded-full text-white", tagBgClass(tag.Color) }>
		{ tag.Name }
		if removable {
			<button
				type="button"
				class="ml-0.5 hover:bg-white/20 rounded-full p-0.5"
				hx-delete={ "/documents/" + documentID + "/tags/" + tag.ID.String() }
				hx-target={ "#doc-" + documentID + "-tags" }
				hx-swap="outerHTML"
				title="Remove tag"
			>
				<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
			</button>
		}
	</span>
}

// TagBadgeSmall renders a smaller tag badge for list view
templ TagBadgeSmall(documentID string, tag sqlc.Tag, removable bool) {
	<span class={ "inline-flex items-center gap-0.5 px-1.5 py-0.5 text-[10px] font-medium rounded text-white", tagBgClass(tag.Color) }>
		{ tag.Name }
		if removable {
			<button
				type="button"
				class="hover:bg-white/20 rounded p-0.5"
				hx-delete={ "/documents/" + documentID + "/tags/" + tag.ID.String() }
				hx-target={ "#inline-picker-" + documentID }
				hx-swap="outerHTML"
				hx-select={ "#inline-picker-" + documentID }
				title="Remove tag"
			>
				<svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
				</svg>
			</button>
		}
	</span>
}

// TagSearchResults renders the search dropdown results
templ TagSearchResults(documentID string, tags []sqlc.Tag, query string, showCreate bool) {
	if len(tags) > 0 || showCreate {
		<ul class="py-1">
			for _, tag := range tags {
				<li>
					<button
						type="button"
						class="w-full px-3 py-2 text-left text-sm hover:bg-muted flex items-center gap-2"
						hx-post={ "/documents/" + documentID + "/tags" }
						hx-vals={ `{"tag_id":"` + tag.ID.String() + `"}` }
						hx-target={ "#doc-" + documentID + "-tags" }
						hx-swap="outerHTML"
					>
						<span class={ "w-3 h-3 rounded-full", tagBgClass(tag.Color) }></span>
						{ tag.Name }
					</button>
				</li>
			}
			if showCreate {
				<li class="border-t border-border">
					<button
						type="button"
						class="w-full px-3 py-2 text-left text-sm hover:bg-muted flex items-center gap-2 text-primary"
						hx-post={ "/documents/" + documentID + "/tags" }
						hx-vals={ `{"tag_id":"new","name":"` + escapeJSON(query) + `"}` }
						hx-target={ "#doc-" + documentID + "-tags" }
						hx-swap="outerHTML"
					>
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
						</svg>
						Create "{ query }"
					</button>
				</li>
			}
		</ul>
	}
}

// InlineTagSearchResults renders the search dropdown results for inline picker
templ InlineTagSearchResults(documentID string, tags []sqlc.Tag, query string, showCreate bool) {
	if len(tags) > 0 || showCreate {
		<ul class="py-1">
			for _, tag := range tags {
				<li>
					<button
						type="button"
						class="w-full px-2 py-1.5 text-left text-xs hover:bg-muted flex items-center gap-2"
						hx-post={ "/documents/" + documentID + "/tags" }
						hx-vals={ `{"tag_id":"` + tag.ID.String() + `"}` }
						hx-target={ "#inline-picker-" + documentID }
						hx-swap="outerHTML"
					>
						<span class={ "w-2 h-2 rounded-full", tagBgClass(tag.Color) }></span>
						{ tag.Name }
					</button>
				</li>
			}
			if showCreate {
				<li class="border-t border-border">
					<button
						type="button"
						class="w-full px-2 py-1.5 text-left text-xs hover:bg-muted flex items-center gap-2 text-primary"
						hx-post={ "/documents/" + documentID + "/tags" }
						hx-vals={ `{"tag_id":"new","name":"` + escapeJSON(query) + `"}` }
						hx-target={ "#inline-picker-" + documentID }
						hx-swap="outerHTML"
					>
						<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
						</svg>
						Create "{ query }"
					</button>
				</li>
			}
		</ul>
	}
}

// tagBgClass returns the Tailwind background class for a tag color
func tagBgClass(color *string) string {
	if color == nil {
		return "bg-blue-500"
	}
	switch *color {
	case "red":
		return "bg-red-500"
	case "orange":
		return "bg-orange-500"
	case "amber":
		return "bg-amber-500"
	case "yellow":
		return "bg-yellow-500"
	case "green":
		return "bg-green-500"
	case "emerald":
		return "bg-emerald-500"
	case "teal":
		return "bg-teal-500"
	case "blue":
		return "bg-blue-500"
	case "indigo":
		return "bg-indigo-500"
	case "purple":
		return "bg-purple-500"
	case "pink":
		return "bg-pink-500"
	case "gray":
		return "bg-gray-500"
	default:
		return "bg-blue-500"
	}
}

// escapeJSON escapes a string for use in JSON
func escapeJSON(s string) string {
	result := ""
	for _, c := range s {
		switch c {
		case '"':
			result += `\"`
		case '\\':
			result += `\\`
		case '\n':
			result += `\n`
		case '\r':
			result += `\r`
		case '\t':
			result += `\t`
		default:
			result += string(c)
		}
	}
	return result
}
