package admin

import (
	"fmt"

	"docko/components/button"
	"docko/components/input"
	"docko/components/table"
	"docko/internal/database/sqlc"
	"docko/internal/meta"
	"docko/templates/layouts"
	"docko/templates/partials"
	"github.com/google/uuid"
)

// DocumentTagsMap maps document ID to tags
type DocumentTagsMap map[uuid.UUID][]sqlc.Tag

// DocumentCorrespondentMap maps document ID to correspondent name
type DocumentCorrespondentMap map[uuid.UUID]string

// Documents renders the document list page with real-time status updates (legacy)
templ Documents(docs []sqlc.Document, docTags DocumentTagsMap, docCorrespondents DocumentCorrespondentMap) {
	@layouts.Admin(meta.New("Documents", "View and manage uploaded documents")) {
		<div class="mb-8">
			<div class="flex items-center justify-between">
				<div>
					<h1 class="text-2xl font-bold">Documents</h1>
					<p class="text-muted-foreground">View uploaded documents and processing status.</p>
				</div>
				@button.Button(button.Props{
					Href: "/upload",
				}) {
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
					</svg>
					Upload
				}
			</div>
		</div>
		// SSE connection for real-time status updates
		<div hx-ext="sse" sse-connect="/api/processing/status" sse-close="close">
			// Bulk progress summary (updated via SSE event "bulk-progress")
			<div id="bulk-progress-container" class="mb-4">
				@partials.BulkProgress(countProcessed(docs), len(docs))
			</div>
			if len(docs) == 0 {
				<div class="border border-border rounded-lg p-8 text-center">
					<svg class="w-12 h-12 mx-auto text-muted-foreground mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
					</svg>
					<p class="text-lg font-medium mb-2">No documents yet</p>
					<p class="text-muted-foreground mb-4">Upload your first document to get started.</p>
					@button.Button(button.Props{
						Href: "/upload",
					}) {
						Upload Document
					}
				</div>
			} else {
				<div class="border border-border rounded-lg overflow-hidden">
					@table.Table() {
						@table.Header(table.HeaderProps{Class: "bg-muted/50"}) {
							@table.Row() {
								@table.Head() {
									Filename 
								}
								@table.Head() {
									Tags 
								}
								@table.Head() {
									Correspondent 
								}
								@table.Head() {
									Size 
								}
								@table.Head() {
									Date 
								}
								@table.Head() {
									Status 
								}
							}
						}
						@table.Body() {
							for _, doc := range docs {
								@table.Row() {
									@table.Cell() {
										<div class="flex items-center gap-3">
											<svg class="w-8 h-8 text-red-500 flex-shrink-0" fill="currentColor" viewBox="0 0 24 24">
												<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"></path>
												<path fill="white" d="M14 2v6h6"></path>
												<text x="7" y="17" fill="white" font-size="6" font-weight="bold">PDF</text>
											</svg>
											<a
												href={ templ.SafeURL("/documents/" + doc.ID.String()) }
												class="truncate max-w-xs hover:text-primary hover:underline"
												title={ doc.OriginalFilename }
											>
												{ doc.OriginalFilename }
											</a>
										</div>
									}
									@table.Cell() {
										@partials.InlineTagPicker(doc.ID.String(), getDocTags(docTags, doc.ID))
									}
									@table.Cell() {
										@partials.InlineCorrespondentDisplay(getDocCorrespondent(docCorrespondents, doc.ID))
									}
									@table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
										{ formatFileSize(doc.FileSize) }
									}
									@table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
										{ doc.CreatedAt.Format("Jan 2, 2006") }
									}
									@table.Cell() {
										// Status badge - swapped by SSE event "doc-{id}"
										<div sse-swap={ "doc-" + doc.ID.String() } hx-swap="innerHTML">
											@partials.DocumentStatus(doc.ID.String(), string(doc.ProcessingStatus), derefStr(doc.ProcessingError))
										</div>
									}
								}
							}
						}
					}
				</div>
			}
		</div>
	}
}

// getDocTags safely retrieves tags for a document ID from the map
func getDocTags(docTags DocumentTagsMap, docID uuid.UUID) []sqlc.Tag {
	if docTags == nil {
		return []sqlc.Tag{}
	}
	tags, ok := docTags[docID]
	if !ok {
		return []sqlc.Tag{}
	}
	return tags
}

// getDocCorrespondent safely retrieves correspondent name for a document ID from the map
func getDocCorrespondent(docCorrespondents DocumentCorrespondentMap, docID uuid.UUID) *string {
	if docCorrespondents == nil {
		return nil
	}
	name, ok := docCorrespondents[docID]
	if !ok || name == "" {
		return nil
	}
	return &name
}

// formatFileSize returns human-readable file size
func formatFileSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

// countProcessed returns count of completed documents
func countProcessed(docs []sqlc.Document) int {
	count := 0
	for _, doc := range docs {
		if doc.ProcessingStatus == sqlc.ProcessingStatusCompleted {
			count++
		}
	}
	return count
}

// derefStr safely dereferences a string pointer
func derefStr(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}

// DocumentsWithSearch renders the document list page with search support
templ DocumentsWithSearch(results []partials.SearchResult, docTags partials.DocumentTagsMap, docCorrespondents partials.DocumentCorrespondentMap, params partials.SearchParams, totalCount int, activeFilters []partials.ActiveFilter, allTags []sqlc.Tag, allCorrespondents []sqlc.Correspondent) {
	@layouts.Admin(meta.New("Documents", "Search and manage your documents")) {
		<div class="mb-6">
			<div class="flex items-center justify-between mb-4">
				<div>
					<h1 class="text-2xl font-bold">Documents</h1>
					<p class="text-muted-foreground">Search and filter your document library.</p>
				</div>
				@button.Button(button.Props{
					Href: "/upload",
				}) {
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
					</svg>
					Upload
				}
			</div>
			// Search form with HTMX
			<form
				id="search-form"
				hx-get="/documents"
				hx-trigger="input changed delay:500ms from:find input[name='q'], change from:find select, change from:find input[type='checkbox'], submit"
				hx-target="#document-results"
				hx-push-url="true"
				hx-indicator="#search-indicator"
				class="space-y-4"
			>
				// Search input row with filters
				<div class="flex gap-4">
					// Search input with icon and loading indicator
					<div class="relative flex-1">
						<svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-muted-foreground pointer-events-none z-10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
						</svg>
						@input.Input(input.Props{
							Type:        input.TypeSearch,
							Name:        "q",
							Placeholder: "Search documents...",
							Value:       params.Query,
							Class:       "pl-10 pr-10",
						})
						// Loading indicator
						<span id="search-indicator" class="htmx-indicator absolute right-3 top-1/2 -translate-y-1/2 z-10">
							<svg class="animate-spin w-4 h-4 text-muted-foreground" fill="none" viewBox="0 0 24 24">
								<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
								<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
							</svg>
						</span>
					</div>
					// Correspondent filter dropdown (styled to match templUI)
					<select
						name="correspondent"
						class="flex h-9 min-w-[180px] rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-xs transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"
					>
						<option value="">All correspondents</option>
						for _, corr := range allCorrespondents {
							<option value={ corr.ID.String() } selected?={ params.CorrespondentID == corr.ID.String() }>
								{ corr.Name }
							</option>
						}
					</select>
					// Date range filter dropdown (styled to match templUI)
					<select
						name="date"
						class="flex h-9 min-w-[140px] rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-xs transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"
					>
						<option value="">Any time</option>
						<option value="today" selected?={ params.DateRange == "today" }>Today</option>
						<option value="7d" selected?={ params.DateRange == "7d" }>Last 7 days</option>
						<option value="30d" selected?={ params.DateRange == "30d" }>Last 30 days</option>
						<option value="1y" selected?={ params.DateRange == "1y" }>Last year</option>
					</select>
				</div>
				// Tag filter row (multi-select checkboxes)
				if len(allTags) > 0 {
					<div class="flex flex-wrap items-center gap-2">
						<span class="text-sm text-muted-foreground">Tags:</span>
						for _, tag := range allTags {
							@tagFilterCheckbox(tag, params.TagIDs)
						}
					</div>
				}
			</form>
		</div>
		// Results area (swapped by HTMX) with SSE for processing status
		<div id="document-results" hx-ext="sse" sse-connect="/api/processing/status" sse-close="close">
			@partials.SearchResults(results, docTags, docCorrespondents, params, totalCount, activeFilters)
		</div>
		@input.Script()
		// CSS for htmx-indicator (hidden by default, shown during request)
		<style>
			.htmx-indicator { opacity: 0; transition: opacity 200ms ease-in; }
			.htmx-request .htmx-indicator { opacity: 1; }
			.htmx-request.htmx-indicator { opacity: 1; }
		</style>
	}
}

// tagFilterCheckbox renders a single tag filter toggle with improved styling
templ tagFilterCheckbox(tag sqlc.Tag, selectedTagIDs []string) {
	{{
		isSelected := false
		for _, selectedID := range selectedTagIDs {
			if selectedID == tag.ID.String() {
				isSelected = true
				break
			}
		}
	}}
	<label
		class={ "inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-sm cursor-pointer transition-colors border",
				   templ.KV("bg-primary text-primary-foreground border-primary", isSelected),
				   templ.KV("bg-transparent hover:bg-muted border-input", !isSelected) }
	>
		<input
			type="checkbox"
			name="tag"
			value={ tag.ID.String() }
			checked?={ isSelected }
			class="sr-only"
		/>
		if tag.Color != nil {
			<span class={ "w-2 h-2 rounded-full", tagColorClass(tag.Color) }></span>
		}
		{ tag.Name }
	</label>
}
