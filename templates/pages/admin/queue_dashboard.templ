package admin

import (
	"fmt"
	"strconv"

	"docko/components/badge"
	"docko/components/button"
	"docko/components/card"
	"docko/components/collapsible"
	"docko/components/skeleton"
	"docko/internal/database/sqlc"
	"docko/internal/meta"
	"docko/templates/layouts"
)

templ QueueDashboard(stats []sqlc.GetQueueStatsRow) {
	@layouts.Admin(meta.New("Queue Dashboard", "Monitor job queues")) {
		<div class="space-y-6">
			<div class="flex items-center justify-between">
				<h1 class="text-2xl font-bold">Queue Dashboard</h1>
				if hasAnyFailed(stats) {
					@button.Button(button.Props{
						Attributes: templ.Attributes{
							"hx-post": "/queues/retry-all",
							"hx-swap": "none",
						},
					}) {
						Retry All Failed
					}
				}
			</div>
			// Queue sections with collapsible detail
			<div class="space-y-4">
				{{ queueMap := aggregateQueueStats(stats) }}
				for queueName, counts := range queueMap {
					@queueSection(queueName, counts)
				}
				if len(queueMap) == 0 {
					@card.Card() {
						@card.Content() {
							<div class="py-8 text-center text-muted-foreground">
								No queues found. Jobs will appear here when documents are processed.
							</div>
						}
					}
				}
			</div>
		</div>
		// Toast container
		<div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>
		<script>
		function showToast(message, isError) {
			const container = document.getElementById('toast-container');
			const toast = document.createElement('div');
			toast.className = `px-4 py-3 rounded-lg shadow-lg text-sm font-medium transition-all duration-300 ${
				isError
					? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-800'
					: 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-800'
			}`;
			toast.textContent = message;
			container.appendChild(toast);

			setTimeout(() => {
				toast.style.opacity = '0';
				setTimeout(() => toast.remove(), 300);
			}, 5000);
		}

		document.body.addEventListener('showToast', function(evt) {
			const detail = evt.detail;
			showToast(detail.message, detail.type === 'error');
		});
		</script>
		<style>
		[data-tui-collapsible-state="open"] .collapsible-chevron {
			transform: rotate(90deg);
		}
		</style>
	}
}

templ queueSection(queueName string, counts map[string]int64) {
	@card.Card() {
		@collapsible.Collapsible() {
			@collapsible.Trigger(collapsible.TriggerProps{Class: "w-full cursor-pointer"}) {
				<div class="flex items-center justify-between p-4">
					<div class="flex items-center gap-3">
						// Chevron icon for expand/collapse indicator
						<svg class="h-4 w-4 shrink-0 transition-transform duration-200 collapsible-chevron"
						     xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
						     stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
							<polyline points="9 18 15 12 9 6"></polyline>
						</svg>
						<span class="text-lg font-medium">{ queueName }</span>
						@queueHealthBadge(counts)
					</div>
					<div class="flex items-center gap-4">
						@queueCountBadges(counts)
						if counts["failed"] > 0 {
							<div class="flex gap-2" onclick="event.stopPropagation()">
								@button.Button(button.Props{
									Size: button.SizeSm,
									Attributes: templ.Attributes{
										"hx-post": fmt.Sprintf("/queues/%s/retry-all", queueName),
										"hx-swap": "none",
									},
								}) {
									Retry All
								}
							</div>
						}
					</div>
				</div>
			}
			@collapsible.Content() {
				// Lazy load content on first expand
				<div
					hx-get={ fmt.Sprintf("/queues/%s/details", queueName) }
					hx-trigger="intersect once"
					hx-swap="innerHTML"
				>
					@skeleton.Skeleton(skeleton.Props{Class: "h-40 w-full m-4"})
				</div>
			}
		}
	}
}

templ queueCountBadges(counts map[string]int64) {
	<div class="flex gap-2">
		if counts["pending"] > 0 {
			@badge.Badge(badge.Props{Variant: badge.VariantSecondary}) {
				{ strconv.FormatInt(counts["pending"], 10) } pending
			}
		}
		if counts["processing"] > 0 {
			@badge.Badge(badge.Props{Class: "animate-pulse"}) {
				{ strconv.FormatInt(counts["processing"], 10) } processing
			}
		}
		@badge.Badge(badge.Props{Class: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 border-transparent"}) {
			{ strconv.FormatInt(counts["completed"], 10) } completed
		}
		if counts["failed"] > 0 {
			@badge.Badge(badge.Props{Variant: badge.VariantDestructive}) {
				{ strconv.FormatInt(counts["failed"], 10) } failed
			}
		}
	</div>
}

templ queueHealthBadge(counts map[string]int64) {
	// Health status: issues if failed>0, warning if pending>=10, healthy otherwise
	if counts["failed"] > 0 {
		@badge.Badge(badge.Props{Variant: badge.VariantDestructive}) {
			Issues
		}
	} else if counts["pending"] >= 10 {
		@badge.Badge(badge.Props{Class: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 border-transparent"}) {
			Warning
		}
	} else {
		@badge.Badge(badge.Props{Class: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 border-transparent"}) {
			Healthy
		}
	}
}

func aggregateQueueStats(stats []sqlc.GetQueueStatsRow) map[string]map[string]int64 {
	result := make(map[string]map[string]int64)
	for _, s := range stats {
		if _, ok := result[s.QueueName]; !ok {
			result[s.QueueName] = make(map[string]int64)
		}
		result[s.QueueName][string(s.Status)] = s.Count
	}
	return result
}

func hasAnyFailed(stats []sqlc.GetQueueStatsRow) bool {
	for _, s := range stats {
		if s.Status == sqlc.JobStatusFailed && s.Count > 0 {
			return true
		}
	}
	return false
}

func safeString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
