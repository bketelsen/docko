package admin

import (
	"strconv"

	"docko/components/badge"
	"docko/components/button"
	"docko/components/card"
	"docko/components/table"
	"docko/internal/database/sqlc"
	"docko/internal/meta"
	"docko/templates/layouts"
)

templ QueueDashboard(stats []sqlc.GetQueueStatsRow, failedJobs, recentJobs []sqlc.Job) {
	@layouts.Admin(meta.New("Queue Dashboard", "Monitor job queues")) {
		<div class="space-y-6">
			<h1 class="text-2xl font-bold">Queue Dashboard</h1>
			<!-- Queue Stats -->
			<div class="grid grid-cols-1 md:grid-cols-3 gap-4">
				@queueStatCards(stats)
			</div>
			<!-- Failed Jobs -->
			@card.Card() {
				@card.Header(card.HeaderProps{Class: "flex flex-row items-center justify-between"}) {
					@card.Title() {
						Failed Jobs
					}
					if len(failedJobs) > 0 {
						@button.Button(button.Props{
							Size: button.SizeSm,
							Attributes: templ.Attributes{
								"hx-post": "/queues/retry-all",
								"hx-swap": "none",
							},
						}) {
							Retry All Failed
						}
					}
				}
				@card.Content(card.ContentProps{Class: "pt-0"}) {
					if len(failedJobs) == 0 {
						<div class="py-6 text-center text-muted-foreground">
							No failed jobs
						</div>
					} else {
						@table.Table() {
							@table.Header() {
								@table.Row() {
									@table.Head() {
										Queue 
									}
									@table.Head() {
										Type 
									}
									@table.Head() {
										Attempts 
									}
									@table.Head() {
										Last Error 
									}
									@table.Head() {
										Actions 
									}
								}
							}
							@table.Body() {
								for _, job := range failedJobs {
									@table.Row() {
										@table.Cell() {
											{ job.QueueName }
										}
										@table.Cell() {
											{ job.JobType }
										}
										@table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
											{ strconv.Itoa(int(job.Attempt)) }/{ strconv.Itoa(int(job.MaxAttempts)) }
										}
										@table.Cell(table.CellProps{Class: "max-w-xs truncate"}) {
											<span class="text-destructive" title={ safeString(job.LastError) }>
												{ safeString(job.LastError) }
											</span>
										}
										@table.Cell() {
											@button.Button(button.Props{
												Size: button.SizeSm,
												Attributes: templ.Attributes{
													"hx-post": "/queues/jobs/" + job.ID.String() + "/retry",
													"hx-swap": "none",
												},
											}) {
												Retry
											}
										}
									}
								}
							}
						}
					}
				}
			}
			<!-- Recent Jobs -->
			@card.Card() {
				@card.Header() {
					@card.Title() {
						Recent Activity
					}
				}
				@card.Content(card.ContentProps{Class: "pt-0"}) {
					if len(recentJobs) == 0 {
						<div class="py-6 text-center text-muted-foreground">
							No recent jobs
						</div>
					} else {
						@table.Table() {
							@table.Header() {
								@table.Row() {
									@table.Head() {
										Queue 
									}
									@table.Head() {
										Type 
									}
									@table.Head() {
										Status 
									}
									@table.Head() {
										Created 
									}
								}
							}
							@table.Body() {
								for _, job := range recentJobs {
									@table.Row() {
										@table.Cell() {
											{ job.QueueName }
										}
										@table.Cell() {
											{ job.JobType }
										}
										@table.Cell() {
											@jobStatusBadge(job.Status)
										}
										@table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
											{ job.CreatedAt.Format("Jan 2 15:04") }
										}
									}
								}
							}
						}
					}
				}
			}
		</div>
		<!-- Toast container -->
		<div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>
		<script>
		function showToast(message, isError) {
			const container = document.getElementById('toast-container');
			const toast = document.createElement('div');
			toast.className = `px-4 py-3 rounded-lg shadow-lg text-sm font-medium transition-all duration-300 ${
				isError
					? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-800'
					: 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-800'
			}`;
			toast.textContent = message;
			container.appendChild(toast);

			setTimeout(() => {
				toast.style.opacity = '0';
				setTimeout(() => toast.remove(), 300);
			}, 5000);
		}

		document.body.addEventListener('showToast', function(evt) {
			const detail = evt.detail;
			showToast(detail.message, detail.type === 'error');
		});
		</script>
	}
}

templ queueStatCards(stats []sqlc.GetQueueStatsRow) {
	{{ queueMap := aggregateQueueStats(stats) }}
	for queueName, counts := range queueMap {
		@card.Card() {
			@card.Header(card.HeaderProps{Class: "pb-2"}) {
				@card.Title(card.TitleProps{Class: "text-base"}) {
					{ queueName }
				}
			}
			@card.Content(card.ContentProps{Class: "pt-0"}) {
				<div class="grid grid-cols-2 gap-4 text-sm">
					<div>
						<span class="text-muted-foreground">Pending:</span>
						<span class="ml-2 font-medium">{ strconv.FormatInt(counts["pending"], 10) }</span>
					</div>
					<div>
						<span class="text-muted-foreground">Processing:</span>
						<span class="ml-2 font-medium">{ strconv.FormatInt(counts["processing"], 10) }</span>
					</div>
					<div>
						<span class="text-muted-foreground">Completed:</span>
						<span class="ml-2 font-medium text-green-600 dark:text-green-400">{ strconv.FormatInt(counts["completed"], 10) }</span>
					</div>
					<div>
						<span class="text-muted-foreground">Failed:</span>
						<span class="ml-2 font-medium text-destructive">{ strconv.FormatInt(counts["failed"], 10) }</span>
					</div>
				</div>
			}
		}
	}
}

templ jobStatusBadge(status sqlc.JobStatus) {
	switch status {
		case sqlc.JobStatusPending:
			@badge.Badge(badge.Props{Variant: badge.VariantSecondary}) {
				Pending
			}
		case sqlc.JobStatusProcessing:
			@badge.Badge(badge.Props{Class: "animate-pulse"}) {
				Processing
			}
		case sqlc.JobStatusCompleted:
			@badge.Badge(badge.Props{Class: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 border-transparent"}) {
				Completed
			}
		case sqlc.JobStatusFailed:
			@badge.Badge(badge.Props{Variant: badge.VariantDestructive}) {
				Failed
			}
	}
}

func aggregateQueueStats(stats []sqlc.GetQueueStatsRow) map[string]map[string]int64 {
	result := make(map[string]map[string]int64)
	for _, s := range stats {
		if _, ok := result[s.QueueName]; !ok {
			result[s.QueueName] = make(map[string]int64)
		}
		result[s.QueueName][string(s.Status)] = s.Count
	}
	return result
}

func safeString(s *string) string {
	if s == nil {
		return ""
	}
	return *s
}
