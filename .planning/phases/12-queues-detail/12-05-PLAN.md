---
phase: 12-queues-detail
plan: 05
type: execute
wave: 3
depends_on: ["12-03", "12-04"]
files_modified:
  - internal/processing/status.go
  - internal/handler/status.go
  - templates/pages/admin/queue_detail.templ
autonomous: false

must_haves:
  truths:
    - "SSE broadcasts queue-level job completion events"
    - "Recent activity section updates in real-time"
    - "User can verify queue expanders function correctly"
  artifacts:
    - path: "internal/processing/status.go"
      provides: "QueueActivityUpdate type for SSE"
      contains: "QueueActivityUpdate"
    - path: "internal/handler/status.go"
      provides: "SSE endpoint with queue events"
      contains: "queue-"
  key_links:
    - from: "internal/handler/status.go"
      to: "templates/pages/admin/queue_detail.templ"
      via: "SSE event rendering"
      pattern: "sse-swap"
---

<objective>
Add SSE support for real-time queue activity updates and verify complete implementation.

Purpose: Enable live updates in the recent activity section as jobs complete.
Output: Extended SSE broadcaster for queue events, updated templates with SSE listeners.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-queues-detail/12-03-SUMMARY.md
@.planning/phases/12-queues-detail/12-04-SUMMARY.md
@internal/processing/status.go
@internal/handler/status.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StatusBroadcaster for queue events</name>
  <files>internal/processing/status.go</files>
  <action>
Add a QueueActivityUpdate type and extend the broadcaster to support queue-level events.

Option A (Simpler - Recommended): Add QueueName field to existing StatusUpdate:

```go
// StatusUpdate represents a processing status change
type StatusUpdate struct {
    DocumentID uuid.UUID
    Status     string // pending, processing, completed, failed
    Error      string // error message if failed
    QueueName  string // NEW: queue name for queue-level events
}
```

This allows the existing broadcaster to carry queue info. The SSE handler can then format events as `queue-{name}` for queue-specific updates.

The processor already calls `broadcaster.Broadcast()` when jobs complete. We just need to include the queue name in the update.

Update the processor.go where it broadcasts status updates to include the queue name:

In internal/processing/processor.go, find where Broadcast is called and add QueueName:

```go
// After job completion
h.broadcaster.Broadcast(processing.StatusUpdate{
    DocumentID: docID,
    Status:     "completed", // or "failed"
    Error:      "", // error if failed
    QueueName:  "default", // or the actual queue name from the job
})
```

Note: The queue name is available from the job being processed. Check how the processor accesses job info.
  </action>
  <verify>Check that StatusUpdate struct has QueueName field and processor populates it</verify>
  <done>StatusUpdate extended with QueueName field for queue-level SSE events</done>
</task>

<task type="auto">
  <name>Task 2: Add SSE event for queue activity</name>
  <files>internal/handler/status.go</files>
  <action>
Update the SSE handler to emit queue-specific events in addition to document events.

In the ProcessingStatus handler, after sending the document-specific event, also send a queue-level event:

```go
case update, ok := <-updates:
    if !ok {
        return nil
    }

    // Render document status partial (existing)
    var buf bytes.Buffer
    if err := partials.DocumentStatus(
        update.DocumentID.String(),
        update.Status,
        update.Error,
    ).Render(ctx, &buf); err != nil {
        slog.Error("failed to render status partial",
            "doc_id", update.DocumentID,
            "error", err)
        continue
    }

    // Send document-specific event (existing)
    fmt.Fprintf(w, "event: doc-%s\ndata: %s\n\n",
        update.DocumentID.String(),
        buf.String(),
    )

    // NEW: Send queue activity event if queue name is set
    if update.QueueName != "" {
        // Render a queue activity row partial
        var queueBuf bytes.Buffer
        if err := partials.QueueActivityRow(
            update.DocumentID.String(),
            update.Status,
        ).Render(ctx, &queueBuf); err == nil {
            fmt.Fprintf(w, "event: queue-%s\ndata: %s\n\n",
                update.QueueName,
                queueBuf.String(),
            )
        }
    }

    flusher.Flush()
```

Also create the QueueActivityRow partial in templates/partials/:

```templ
package partials

import "time"

templ QueueActivityRow(docID string, status string) {
    <tr class="animate-pulse-once">
        <td class="px-4 py-2">
            <a href={ templ.SafeURL("/documents/" + docID) } class="text-primary hover:underline">
                Document
            </a>
        </td>
        <td class="px-4 py-2">{ status }</td>
        <td class="px-4 py-2 text-muted-foreground">just now</td>
    </tr>
}
```

Note: This is a simplified approach. The activity section could prepend new rows via SSE. The exact implementation depends on how the collapsible content is structured.
  </action>
  <verify>Check that SSE handler sends both doc-{id} and queue-{name} events</verify>
  <done>SSE handler extended to emit queue-level activity events</done>
</task>

<task type="auto">
  <name>Task 3: Add SSE listener to queue detail template</name>
  <files>templates/pages/admin/queue_detail.templ</files>
  <action>
Add SSE listener to the recent activity section for live updates.

Update QueueDetailContent to include an SSE connection that listens for queue events:

```templ
// Recent Activity Section with SSE listener
<div id={ fmt.Sprintf("queue-%s-activity", queueName) }
     hx-ext="sse"
     sse-connect="/api/processing/status"
     sse-swap={ fmt.Sprintf("queue-%s", queueName) }>
    @card.Card() {
        @card.Header(card.HeaderProps{Class: "py-3"}) {
            @card.Title(card.TitleProps{Class: "text-base"}) {
                Recent Activity (Last 24h)
                <span class="ml-2 text-xs text-muted-foreground">(live)</span>
            }
        }
        @card.Content(card.ContentProps{Class: "p-0"}) {
            if len(recentJobs) == 0 {
                <div class="text-center py-4 text-muted-foreground" id={ fmt.Sprintf("queue-%s-empty", queueName) }>
                    No recent completed jobs
                </div>
            } else {
                @table.Table() {
                    @table.Header() {
                        @table.Row() {
                            @table.Head() { Document }
                            @table.Head() { Type }
                            @table.Head() { Completed }
                        }
                    }
                    @table.Body() {
                        for _, job := range recentJobs {
                            @recentJobRow(job)
                        }
                    }
                }
            }
        }
    }
</div>
```

Note: The SSE swap will append/prepend new activity rows as jobs complete. The existing SSE connection at `/api/processing/status` is reused.
  </action>
  <verify>Check that queue detail template has sse-connect and sse-swap attributes</verify>
  <done>SSE listener added to recent activity section for live updates</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete queue detail functionality with expandable sections, lazy loading, job actions, and SSE live updates</what-built>
  <how-to-verify>
1. Navigate to http://localhost:3000/queues
2. Verify each queue shows:
   - Queue name
   - Health badge (Healthy/Warning/Issues)
   - Count badges (pending, processing, completed, failed)
   - Retry All button (if failed jobs exist)
3. Click a queue to expand it:
   - Skeleton loader should appear briefly
   - Failed jobs table loads with document links
   - Recent activity shows last 24h of completed jobs
4. Test job actions:
   - Click Retry on a failed job -> toast confirms retry
   - Click Dismiss on a failed job -> row disappears (outerHTML swap)
   - Click Retry All -> all failed jobs in queue retried
   - Click Clear All -> confirmation dialog appears -> click Clear Jobs -> jobs dismissed
5. Test document links:
   - Click document name in failed jobs -> navigates to document detail
   - Click document name in recent activity -> navigates to document detail
6. Test SSE (if jobs are processing):
   - Keep queue expanded
   - Upload a new document
   - Observe recent activity updates in real-time
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. SSE StatusUpdate struct has QueueName field
2. Processor populates QueueName when broadcasting
3. SSE handler emits queue-{name} events
4. Queue detail template has SSE listener
5. All queue actions work (retry, dismiss, clear)
6. Document links navigate correctly
</verification>

<success_criteria>
- Queues page shows collapsible sections per queue
- Expanding lazy-loads failed jobs and recent activity
- Failed jobs show document links, error messages, actions
- Single job retry/dismiss works instantly
- Bulk retry/clear works with confirmation for clear
- SSE updates recent activity in real-time (if processing)
- Health badges reflect queue status accurately
</success_criteria>

<output>
After completion, create `.planning/phases/12-queues-detail/12-05-SUMMARY.md`
</output>
