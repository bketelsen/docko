---
phase: 12-queues-detail
plan: 04
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - templates/pages/admin/queue_dashboard.templ
  - templates/pages/admin/queue_detail.templ
autonomous: true

must_haves:
  truths:
    - "Queue dashboard shows collapsible sections per queue"
    - "Each section shows queue name, job counts, and health badge"
    - "Expanding section lazy-loads failed jobs and recent activity"
    - "Failed jobs show document name as clickable link"
    - "Bulk actions (Retry All, Clear All) in collapsed header"
  artifacts:
    - path: "templates/pages/admin/queue_dashboard.templ"
      provides: "Refactored queue dashboard with collapsible sections"
      contains: "collapsible.Collapsible"
    - path: "templates/pages/admin/queue_detail.templ"
      provides: "Lazy-loaded queue detail content"
      contains: "QueueDetailContent"
  key_links:
    - from: "templates/pages/admin/queue_dashboard.templ"
      to: "/queues/:name/details"
      via: "hx-get for lazy loading"
      pattern: "hx-get=\"/queues/"
---

<objective>
Refactor queue dashboard template to use collapsible sections with lazy-loaded content.

Purpose: Replace flat table layout with expandable queue sections showing failed jobs and recent activity.
Output: Updated queue_dashboard.templ and new queue_detail.templ partial.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-queues-detail/12-01-SUMMARY.md
@.planning/phases/12-queues-detail/12-02-SUMMARY.md
@templates/pages/admin/queue_dashboard.templ
@components/collapsible/collapsible.templ
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create queue detail content partial</name>
  <files>templates/pages/admin/queue_detail.templ</files>
  <action>
Create new template file for lazy-loaded queue detail content:

```templ
package admin

import (
    "fmt"
    "strconv"
    "time"

    "docko/components/badge"
    "docko/components/button"
    "docko/components/card"
    "docko/components/dialog"
    "docko/components/table"
    "docko/internal/database/sqlc"
)

// QueueDetailContent renders the expanded content for a queue section
templ QueueDetailContent(queueName string, failedJobs []sqlc.GetFailedJobsForQueueRow, recentJobs []sqlc.GetRecentCompletedJobsForQueueRow) {
    <div class="space-y-4 p-4">
        // Failed Jobs Section
        if len(failedJobs) > 0 {
            @card.Card() {
                @card.Header(card.HeaderProps{Class: "flex flex-row items-center justify-between py-3"}) {
                    @card.Title(card.TitleProps{Class: "text-base"}) {
                        Failed Jobs
                    }
                    <div class="flex gap-2">
                        @button.Button(button.Props{
                            Size: button.SizeSm,
                            Attributes: templ.Attributes{
                                "hx-post": fmt.Sprintf("/queues/%s/retry-all", queueName),
                                "hx-swap": "none",
                            },
                        }) {
                            Retry All
                        }
                        @clearAllDialog(queueName, len(failedJobs))
                    </div>
                }
                @card.Content(card.ContentProps{Class: "p-0"}) {
                    @table.Table() {
                        @table.Header() {
                            @table.Row() {
                                @table.Head() { Document }
                                @table.Head() { Type }
                                @table.Head() { Attempts }
                                @table.Head() { Error }
                                @table.Head() { Failed }
                                @table.Head() { Actions }
                            }
                        }
                        @table.Body() {
                            for _, job := range failedJobs {
                                @failedJobRow(job)
                            }
                        }
                    }
                }
            }
        } else {
            <div class="text-center py-4 text-muted-foreground">
                No failed jobs in this queue
            </div>
        }

        // Recent Activity Section
        @card.Card() {
            @card.Header(card.HeaderProps{Class: "py-3"}) {
                @card.Title(card.TitleProps{Class: "text-base"}) {
                    Recent Activity (Last 24h)
                }
            }
            @card.Content(card.ContentProps{Class: "p-0"}) {
                if len(recentJobs) == 0 {
                    <div class="text-center py-4 text-muted-foreground">
                        No recent completed jobs
                    </div>
                } else {
                    @table.Table() {
                        @table.Header() {
                            @table.Row() {
                                @table.Head() { Document }
                                @table.Head() { Type }
                                @table.Head() { Completed }
                            }
                        }
                        @table.Body() {
                            for _, job := range recentJobs {
                                @recentJobRow(job)
                            }
                        }
                    }
                }
            }
        }
    </div>
}

templ failedJobRow(job sqlc.GetFailedJobsForQueueRow) {
    <tr id={ fmt.Sprintf("job-%s", job.ID.String()) } class="hover:bg-muted/50">
        @table.Cell() {
            if job.DocumentID.Valid {
                <a href={ templ.SafeURL(fmt.Sprintf("/documents/%s", job.DocumentID.UUID.String())) }
                   class="text-primary hover:underline">
                    { safeNullString(job.DocumentName) }
                </a>
            } else {
                <span class="text-muted-foreground">N/A</span>
            }
        }
        @table.Cell() {
            { job.JobType }
        }
        @table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
            { strconv.Itoa(int(job.Attempt)) }/{ strconv.Itoa(int(job.MaxAttempts)) }
        }
        @table.Cell(table.CellProps{Class: "max-w-xs"}) {
            <div class="truncate text-destructive" title={ safeString(job.LastError) }>
                { safeString(job.LastError) }
            </div>
        }
        @table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
            { formatTimeAgo(job.UpdatedAt) }
        }
        @table.Cell() {
            <div class="flex gap-2">
                @button.Button(button.Props{
                    Size: button.SizeSm,
                    Attributes: templ.Attributes{
                        "hx-post": fmt.Sprintf("/queues/jobs/%s/retry", job.ID.String()),
                        "hx-swap": "none",
                    },
                }) {
                    Retry
                }
                @button.Button(button.Props{
                    Size: button.SizeSm,
                    Variant: button.VariantOutline,
                    Attributes: templ.Attributes{
                        "hx-post": fmt.Sprintf("/queues/jobs/%s/dismiss", job.ID.String()),
                        "hx-target": fmt.Sprintf("#job-%s", job.ID.String()),
                        "hx-swap": "outerHTML",
                    },
                }) {
                    Dismiss
                }
            </div>
        }
    </tr>
}

templ recentJobRow(job sqlc.GetRecentCompletedJobsForQueueRow) {
    @table.Row() {
        @table.Cell() {
            if job.DocumentID.Valid {
                <a href={ templ.SafeURL(fmt.Sprintf("/documents/%s", job.DocumentID.UUID.String())) }
                   class="text-primary hover:underline">
                    { safeNullString(job.DocumentName) }
                </a>
            } else {
                <span class="text-muted-foreground">N/A</span>
            }
        }
        @table.Cell() {
            { job.JobType }
        }
        @table.Cell(table.CellProps{Class: "text-muted-foreground"}) {
            { formatCompletedAt(job.CompletedAt) }
        }
    }
}

templ clearAllDialog(queueName string, count int) {
    @dialog.Dialog() {
        @dialog.Trigger() {
            @button.Button(button.Props{
                Size: button.SizeSm,
                Variant: button.VariantDestructive,
            }) {
                Clear All
            }
        }
        @dialog.Content() {
            @dialog.Header() {
                @dialog.Title() {
                    Clear Failed Jobs
                }
                @dialog.Description() {
                    This will dismiss { strconv.Itoa(count) } failed job(s). They will remain in the database for audit purposes but will no longer appear in the failed jobs list.
                }
            }
            @dialog.Footer() {
                @dialog.Close() {
                    @button.Button(button.Props{Variant: button.VariantOutline}) {
                        Cancel
                    }
                }
                @button.Button(button.Props{
                    Variant: button.VariantDestructive,
                    Attributes: templ.Attributes{
                        "hx-post": fmt.Sprintf("/queues/%s/clear-all", queueName),
                        "hx-swap": "none",
                    },
                }) {
                    Clear Jobs
                }
            }
        }
    }
}

func safeNullString(s *string) string {
    if s == nil {
        return "Unknown"
    }
    return *s
}

func formatTimeAgo(t time.Time) string {
    dur := time.Since(t)
    if dur < time.Minute {
        return "just now"
    }
    if dur < time.Hour {
        return fmt.Sprintf("%dm ago", int(dur.Minutes()))
    }
    if dur < 24*time.Hour {
        return fmt.Sprintf("%dh ago", int(dur.Hours()))
    }
    return t.Format("Jan 2 15:04")
}

func formatCompletedAt(t *time.Time) string {
    if t == nil {
        return "N/A"
    }
    return formatTimeAgo(*t)
}
```

Note: Uses uuid.NullUUID for DocumentID since LEFT JOIN LATERAL may return null. The safeNullString function handles nullable document name.
  </action>
  <verify>Run `make generate` and check ./tmp/air-combined.log for template compilation errors</verify>
  <done>QueueDetailContent template created with failed jobs table and recent activity</done>
</task>

<task type="auto">
  <name>Task 2: Refactor queue dashboard with collapsible sections</name>
  <files>templates/pages/admin/queue_dashboard.templ</files>
  <action>
Refactor the queue_dashboard.templ to use collapsible sections per queue:

1. Add collapsible import
2. Replace queueStatCards with collapsible queue sections
3. Keep the aggregateQueueStats helper function
4. Add health badge matching dashboard pattern

Key changes:
- Each queue becomes a collapsible section
- Collapsed state shows: queue name, job counts (pending/failed/completed), health badge
- Bulk actions (Retry All, Clear All) visible in collapsed header when failed > 0
- Expanding triggers lazy load via hx-get="/queues/{name}/details"
- Remove flat failed jobs table (now in detail view)
- Keep toast container and showToast script

```templ
package admin

import (
    "fmt"
    "strconv"

    "docko/components/badge"
    "docko/components/button"
    "docko/components/card"
    "docko/components/collapsible"
    "docko/components/skeleton"
    "docko/internal/database/sqlc"
    "docko/internal/meta"
    "docko/templates/layouts"
)

templ QueueDashboard(stats []sqlc.GetQueueStatsRow) {
    @layouts.Admin(meta.New("Queue Dashboard", "Monitor job queues")) {
        <div class="space-y-6">
            <div class="flex items-center justify-between">
                <h1 class="text-2xl font-bold">Queue Dashboard</h1>
                if hasAnyFailed(stats) {
                    @button.Button(button.Props{
                        Attributes: templ.Attributes{
                            "hx-post": "/queues/retry-all",
                            "hx-swap": "none",
                        },
                    }) {
                        Retry All Failed
                    }
                }
            </div>

            // Queue sections with collapsible detail
            <div class="space-y-4">
                {{ queueMap := aggregateQueueStats(stats) }}
                for queueName, counts := range queueMap {
                    @queueSection(queueName, counts)
                }
                if len(queueMap) == 0 {
                    @card.Card() {
                        @card.Content() {
                            <div class="py-8 text-center text-muted-foreground">
                                No queues found. Jobs will appear here when documents are processed.
                            </div>
                        }
                    }
                }
            </div>
        </div>
        // Toast container
        <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>
        <script>
        function showToast(message, isError) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `px-4 py-3 rounded-lg shadow-lg text-sm font-medium transition-all duration-300 ${
                isError
                    ? 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 border border-red-200 dark:border-red-800'
                    : 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 border border-green-200 dark:border-green-800'
            }`;
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        }

        document.body.addEventListener('showToast', function(evt) {
            const detail = evt.detail;
            showToast(detail.message, detail.type === 'error');
        });
        </script>
    }
}

templ queueSection(queueName string, counts map[string]int64) {
    @card.Card() {
        @collapsible.Collapsible() {
            @collapsible.Trigger(collapsible.TriggerProps{Class: "w-full"}) {
                <div class="flex items-center justify-between p-4">
                    <div class="flex items-center gap-3">
                        // Chevron icon for expand/collapse indicator
                        <svg class="h-4 w-4 shrink-0 transition-transform duration-200 collapsible-chevron"
                             xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                             stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                        <span class="text-lg font-medium">{ queueName }</span>
                        @queueHealthBadge(counts)
                    </div>
                    <div class="flex items-center gap-4">
                        @queueCountBadges(counts)
                        if counts["failed"] > 0 {
                            <div class="flex gap-2" onclick="event.stopPropagation()">
                                @button.Button(button.Props{
                                    Size: button.SizeSm,
                                    Attributes: templ.Attributes{
                                        "hx-post": fmt.Sprintf("/queues/%s/retry-all", queueName),
                                        "hx-swap": "none",
                                    },
                                }) {
                                    Retry All
                                }
                            </div>
                        }
                    </div>
                </div>
            }
            @collapsible.Content() {
                // Lazy load content on first expand
                <div
                    hx-get={ fmt.Sprintf("/queues/%s/details", queueName) }
                    hx-trigger="intersect once"
                    hx-swap="innerHTML"
                >
                    @skeleton.Skeleton(skeleton.Props{Class: "h-40 w-full m-4"}) {}
                </div>
            }
        }
    }
}

templ queueCountBadges(counts map[string]int64) {
    <div class="flex gap-2">
        if counts["pending"] > 0 {
            @badge.Badge(badge.Props{Variant: badge.VariantSecondary}) {
                { strconv.FormatInt(counts["pending"], 10) } pending
            }
        }
        if counts["processing"] > 0 {
            @badge.Badge(badge.Props{Class: "animate-pulse"}) {
                { strconv.FormatInt(counts["processing"], 10) } processing
            }
        }
        @badge.Badge(badge.Props{Class: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 border-transparent"}) {
            { strconv.FormatInt(counts["completed"], 10) } completed
        }
        if counts["failed"] > 0 {
            @badge.Badge(badge.Props{Variant: badge.VariantDestructive}) {
                { strconv.FormatInt(counts["failed"], 10) } failed
            }
        }
    </div>
}

templ queueHealthBadge(counts map[string]int64) {
    // Health status: issues if failed>0, warning if pending>=10, healthy otherwise
    if counts["failed"] > 0 {
        @badge.Badge(badge.Props{Variant: badge.VariantDestructive}) {
            Issues
        }
    } else if counts["pending"] >= 10 {
        @badge.Badge(badge.Props{Class: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200 border-transparent"}) {
            Warning
        }
    } else {
        @badge.Badge(badge.Props{Class: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 border-transparent"}) {
            Healthy
        }
    }
}

func aggregateQueueStats(stats []sqlc.GetQueueStatsRow) map[string]map[string]int64 {
    result := make(map[string]map[string]int64)
    for _, s := range stats {
        if _, ok := result[s.QueueName]; !ok {
            result[s.QueueName] = make(map[string]int64)
        }
        result[s.QueueName][string(s.Status)] = s.Count
    }
    return result
}

func hasAnyFailed(stats []sqlc.GetQueueStatsRow) bool {
    for _, s := range stats {
        if s.Status == sqlc.JobStatusFailed && s.Count > 0 {
            return true
        }
    }
    return false
}

func safeString(s *string) string {
    if s == nil {
        return ""
    }
    return *s
}
```

CSS for chevron rotation (add to collapsible styles or inline):
The collapsible component may already handle this. If not, add:
```css
[data-state="open"] .collapsible-chevron {
    transform: rotate(90deg);
}
```
  </action>
  <verify>Run `make generate` and check ./tmp/air-combined.log for template compilation errors</verify>
  <done>Queue dashboard refactored with collapsible sections and lazy loading</done>
</task>

<task type="auto">
  <name>Task 3: Update handler to use simplified template signature</name>
  <files>internal/handler/ai.go</files>
  <action>
Update QueueDashboardPage handler to pass only stats (not failed/recent jobs since they're lazy-loaded now):

```go
// QueueDashboardPage renders the queue status dashboard
func (h *Handler) QueueDashboardPage(c echo.Context) error {
    ctx := c.Request().Context()

    // Get queue stats
    stats, err := h.db.Queries.GetQueueStats(ctx)
    if err != nil {
        return echo.NewHTTPError(http.StatusInternalServerError, "failed to get queue stats")
    }

    return admin.QueueDashboard(stats).Render(ctx, c.Response().Writer)
}
```

The handler no longer needs to fetch failedJobs and recentJobs since they're lazy-loaded per queue.
  </action>
  <verify>Run `make generate` and check ./tmp/air-combined.log for compilation errors</verify>
  <done>QueueDashboardPage handler simplified to only pass stats</done>
</task>

</tasks>

<verification>
1. `make generate` succeeds without errors
2. Queue dashboard loads at /queues with collapsible sections
3. Each queue shows: name, health badge, count badges, bulk actions
4. Expanding a queue triggers hx-get to load detail content
5. Failed jobs table shows document links
6. Clear All shows confirmation dialog
</verification>

<success_criteria>
- Collapsible sections work (expand/collapse)
- Lazy loading fetches queue details on first expand
- Health badges show correct status (healthy/warning/issues)
- Document names are clickable links to detail page
- Bulk actions (Retry All, Clear All) function correctly
- Confirmation dialog appears for Clear All
</success_criteria>

<output>
After completion, create `.planning/phases/12-queues-detail/12-04-SUMMARY.md`
</output>
