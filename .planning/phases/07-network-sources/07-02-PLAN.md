---
phase: 07-network-sources
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/network/source.go
  - internal/network/smb.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "System can connect to SMB shares with credentials"
    - "System can list PDF files recursively in SMB shares"
    - "System can download files from SMB shares"
  artifacts:
    - path: "internal/network/source.go"
      provides: "NetworkSource interface definition"
      exports: ["NetworkSource", "RemoteFile"]
    - path: "internal/network/smb.go"
      provides: "SMB client implementation"
      exports: ["SMBSource", "NewSMBSource"]
  key_links:
    - from: "internal/network/smb.go"
      to: "github.com/hirochachacha/go-smb2"
      via: "go get import"
      pattern: "smb2\\.Dialer"
---

<objective>
Implement SMB client for connecting to Windows/Samba network shares.

Purpose: Users need to import documents from SMB shares (Windows file servers, NAS devices). The SMB client handles connection, authentication, file listing, and download operations.
Output: NetworkSource interface and SMBSource implementation using hirochachacha/go-smb2.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-network-sources/07-RESEARCH.md
@.planning/phases/07-network-sources/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define NetworkSource interface</name>
  <files>internal/network/source.go</files>
  <action>
Create the common interface that both SMB and NFS implementations will use:

```go
package network

import (
    "context"
    "io"
    "time"
)

// RemoteFile represents a file found on a network source.
type RemoteFile struct {
    Path    string    // Full path relative to share root
    Name    string    // Filename only
    Size    int64     // File size in bytes
    ModTime time.Time // Last modification time
}

// NetworkSource defines the interface for network file sources (SMB, NFS).
type NetworkSource interface {
    // Test validates that connection can be established.
    // Returns nil on success, error describing the failure otherwise.
    Test(ctx context.Context) error

    // ListPDFs returns all PDF files in the source (recursive).
    // Files are returned in no particular order.
    ListPDFs(ctx context.Context) ([]RemoteFile, error)

    // ReadFile copies file content from remote path to the provided writer.
    ReadFile(ctx context.Context, remotePath string, w io.Writer) error

    // DeleteFile removes a file from the source.
    DeleteFile(ctx context.Context, remotePath string) error

    // MoveFile moves a file to a subfolder within the source.
    // destPath is relative to share root.
    MoveFile(ctx context.Context, remotePath, destPath string) error

    // Close releases any resources (connections, etc).
    Close() error
}
```

This interface is minimal but covers all required operations:
- Test: For "Test Connection" button
- ListPDFs: For sync operations
- ReadFile: For downloading files to local storage
- DeleteFile: For post-import 'delete' action
- MoveFile: For post-import 'move' action
- Close: For cleanup
  </action>
  <verify>Check ./tmp/air-combined.log for compilation errors</verify>
  <done>NetworkSource interface defined with all required methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement SMB client</name>
  <files>internal/network/smb.go, go.mod</files>
  <action>
First, add the dependency:
```bash
go get github.com/hirochachacha/go-smb2
```

Then create the SMB implementation:

```go
package network

import (
    "context"
    "fmt"
    "io"
    "io/fs"
    "net"
    "path/filepath"
    "strings"
    "time"

    "github.com/hirochachacha/go-smb2"
)

const (
    smbPort           = 445
    smbConnectTimeout = 30 * time.Second
)

// SMBSource implements NetworkSource for SMB2/3 shares.
type SMBSource struct {
    host     string
    share    string
    username string
    password string

    // Connection state (created per operation, not persistent)
    conn    net.Conn
    session *smb2.Session
    fs      *smb2.Share
}

// NewSMBSource creates a new SMB source.
// Password should already be decrypted before passing here.
func NewSMBSource(host, share, username, password string) *SMBSource {
    return &SMBSource{
        host:     host,
        share:    share,
        username: username,
        password: password,
    }
}

// connect establishes an SMB connection.
func (s *SMBSource) connect(ctx context.Context) error {
    // Set up connection with timeout
    dialer := &net.Dialer{Timeout: smbConnectTimeout}
    conn, err := dialer.DialContext(ctx, "tcp", fmt.Sprintf("%s:%d", s.host, smbPort))
    if err != nil {
        return fmt.Errorf("dial: %w", err)
    }

    // SMB2 dialer with NTLM auth
    d := &smb2.Dialer{
        Initiator: &smb2.NTLMInitiator{
            User:     s.username,
            Password: s.password,
        },
    }

    session, err := d.DialContext(ctx, conn)
    if err != nil {
        conn.Close()
        return fmt.Errorf("smb dial: %w", err)
    }

    // Mount the share
    share, err := session.Mount(s.share)
    if err != nil {
        session.Logoff()
        conn.Close()
        return fmt.Errorf("mount %s: %w", s.share, err)
    }

    s.conn = conn
    s.session = session
    s.fs = share
    return nil
}

// disconnect closes the SMB connection.
func (s *SMBSource) disconnect() {
    if s.fs != nil {
        s.fs.Umount()
        s.fs = nil
    }
    if s.session != nil {
        s.session.Logoff()
        s.session = nil
    }
    if s.conn != nil {
        s.conn.Close()
        s.conn = nil
    }
}

// Test validates the SMB connection.
func (s *SMBSource) Test(ctx context.Context) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    // Verify we can read the root directory
    _, err := s.fs.ReadDir(".")
    if err != nil {
        return fmt.Errorf("read share root: %w", err)
    }
    return nil
}

// ListPDFs returns all PDF files in the share (recursive).
func (s *SMBSource) ListPDFs(ctx context.Context) ([]RemoteFile, error) {
    if err := s.connect(ctx); err != nil {
        return nil, err
    }
    defer s.disconnect()

    var files []RemoteFile

    // Walk the directory tree using fs.WalkDir
    fsys := s.fs.DirFS(".")
    err := fs.WalkDir(fsys, ".", func(path string, d fs.DirEntry, err error) error {
        // Check context for cancellation
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        if err != nil {
            // Log and continue on errors (e.g., permission denied)
            return nil
        }
        if d.IsDir() {
            return nil
        }

        // Only include PDF files
        if !strings.EqualFold(filepath.Ext(path), ".pdf") {
            return nil
        }

        info, err := d.Info()
        if err != nil {
            return nil // Skip files we can't stat
        }

        files = append(files, RemoteFile{
            Path:    path,
            Name:    d.Name(),
            Size:    info.Size(),
            ModTime: info.ModTime(),
        })
        return nil
    })

    if err != nil {
        return nil, fmt.Errorf("walk directory: %w", err)
    }
    return files, nil
}

// ReadFile copies file content to the provided writer.
func (s *SMBSource) ReadFile(ctx context.Context, remotePath string, w io.Writer) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    f, err := s.fs.Open(remotePath)
    if err != nil {
        return fmt.Errorf("open %s: %w", remotePath, err)
    }
    defer f.Close()

    _, err = io.Copy(w, f)
    if err != nil {
        return fmt.Errorf("copy: %w", err)
    }
    return nil
}

// DeleteFile removes a file from the share.
func (s *SMBSource) DeleteFile(ctx context.Context, remotePath string) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    if err := s.fs.Remove(remotePath); err != nil {
        return fmt.Errorf("remove %s: %w", remotePath, err)
    }
    return nil
}

// MoveFile moves a file to a different path within the share.
func (s *SMBSource) MoveFile(ctx context.Context, remotePath, destPath string) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    // Ensure destination directory exists
    destDir := filepath.Dir(destPath)
    if err := s.fs.MkdirAll(destDir, 0755); err != nil {
        return fmt.Errorf("mkdir %s: %w", destDir, err)
    }

    if err := s.fs.Rename(remotePath, destPath); err != nil {
        return fmt.Errorf("rename %s to %s: %w", remotePath, destPath, err)
    }
    return nil
}

// Close releases resources. For SMB, connections are per-operation,
// so this is a no-op but satisfies the interface.
func (s *SMBSource) Close() error {
    s.disconnect()
    return nil
}
```

Key design decisions:
- Connect per operation (not persistent) - SMB connections go stale after 10-15 min idle
- Use fs.WalkDir for recursive listing (go-smb2 supports io/fs interface)
- 30-second connection timeout per research recommendations
- NTLM authentication (standard for SMB2/3)
  </action>
  <verify>Run `go build ./...` and check ./tmp/air-combined.log for errors</verify>
  <done>SMBSource implements NetworkSource interface and compiles without errors</done>
</task>

</tasks>

<verification>
1. Dependency added: `go mod tidy` shows go-smb2 in go.sum
2. Code compiles: `go build ./...` succeeds
3. Interface satisfied: SMBSource has all methods from NetworkSource
4. Check ./tmp/air-combined.log for any compilation errors
</verification>

<success_criteria>
- NetworkSource interface defines Test, ListPDFs, ReadFile, DeleteFile, MoveFile, Close
- SMBSource implements all interface methods
- go-smb2 dependency added to go.mod
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-network-sources/07-02-SUMMARY.md`
</output>
