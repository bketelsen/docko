---
phase: 07-network-sources
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/database/migrations/008_network_sources.sql
  - sqlc/queries/network_sources.sql
  - internal/network/crypto.go
autonomous: true

must_haves:
  truths:
    - "Network source credentials can be stored encrypted in database"
    - "Network source configuration persists across restarts"
  artifacts:
    - path: "internal/database/migrations/008_network_sources.sql"
      provides: "Network sources and events tables"
      contains: "CREATE TABLE network_sources"
    - path: "sqlc/queries/network_sources.sql"
      provides: "CRUD operations for network sources"
      exports: ["CreateNetworkSource", "GetNetworkSource", "ListNetworkSources"]
    - path: "internal/network/crypto.go"
      provides: "AES-256-GCM credential encryption"
      exports: ["CredentialCrypto", "Encrypt", "Decrypt"]
  key_links:
    - from: "internal/network/crypto.go"
      to: "SESSION_SECRET"
      via: "SHA-256 key derivation"
      pattern: "sha256.Sum256"
---

<objective>
Create database schema for network sources and credential encryption service.

Purpose: Network sources need persistent storage for configuration and credentials. Credentials must be encrypted at rest using AES-256-GCM with a key derived from SESSION_SECRET.
Output: Migration file, sqlc queries, and crypto service ready for use by SMB/NFS clients.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-network-sources/07-RESEARCH.md
@internal/database/migrations/004_inboxes.sql
@sqlc/queries/inboxes.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create network_sources database schema</name>
  <files>internal/database/migrations/008_network_sources.sql</files>
  <action>
Create migration file with:

1. Create enum for protocol type: `CREATE TYPE network_protocol AS ENUM ('smb', 'nfs')`

2. Create enum for post-import action: `CREATE TYPE post_import_action AS ENUM ('leave', 'delete', 'move')`

3. Create `network_sources` table with columns:
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - name VARCHAR(255) NOT NULL
   - protocol network_protocol NOT NULL
   - host VARCHAR(255) NOT NULL (server hostname/IP)
   - share_path VARCHAR(1024) NOT NULL (share name for SMB, export path for NFS)
   - username VARCHAR(255) (nullable - SMB only)
   - password_encrypted TEXT (nullable - encrypted with AES-256-GCM)
   - enabled BOOLEAN NOT NULL DEFAULT false (start disabled until tested)
   - continuous_sync BOOLEAN NOT NULL DEFAULT true (vs manual-only)
   - post_import_action post_import_action NOT NULL DEFAULT 'leave'
   - move_subfolder VARCHAR(255) DEFAULT 'imported' (for 'move' action)
   - duplicate_action duplicate_action NOT NULL DEFAULT 'delete' (reuse existing enum)
   - batch_size INTEGER NOT NULL DEFAULT 100
   - connection_state VARCHAR(50) DEFAULT 'unknown' (unknown/connected/error)
   - consecutive_failures INTEGER NOT NULL DEFAULT 0
   - last_sync_at TIMESTAMPTZ
   - last_error TEXT
   - files_imported INTEGER NOT NULL DEFAULT 0
   - created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
   - updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()

4. Create `network_source_events` table (similar to inbox_events):
   - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - source_id UUID NOT NULL REFERENCES network_sources(id) ON DELETE CASCADE
   - filename VARCHAR(255) NOT NULL
   - remote_path VARCHAR(1024) NOT NULL
   - action VARCHAR(50) NOT NULL (imported, duplicate, error, skipped)
   - document_id UUID REFERENCES documents(id) ON DELETE SET NULL
   - error_message TEXT
   - created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()

5. Create index: `CREATE INDEX idx_network_source_events_source_created ON network_source_events (source_id, created_at DESC)`

Include +goose Down section to drop tables and enums in reverse order.
  </action>
  <verify>Check ./tmp/air-combined.log for migration errors after save</verify>
  <done>Migration file exists and applies cleanly on startup</done>
</task>

<task type="auto">
  <name>Task 2: Create sqlc queries for network sources</name>
  <files>sqlc/queries/network_sources.sql</files>
  <action>
Create sqlc query file with these operations:

```sql
-- name: CreateNetworkSource :one
INSERT INTO network_sources (
    name, protocol, host, share_path, username, password_encrypted,
    enabled, continuous_sync, post_import_action, move_subfolder,
    duplicate_action, batch_size
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING *;

-- name: GetNetworkSource :one
SELECT * FROM network_sources WHERE id = $1;

-- name: ListNetworkSources :many
SELECT * FROM network_sources ORDER BY created_at ASC;

-- name: ListEnabledNetworkSources :many
SELECT * FROM network_sources WHERE enabled = true ORDER BY created_at ASC;

-- name: ListContinuousSyncSources :many
SELECT * FROM network_sources
WHERE enabled = true AND continuous_sync = true
ORDER BY created_at ASC;

-- name: UpdateNetworkSource :one
UPDATE network_sources SET
    name = $2, protocol = $3, host = $4, share_path = $5,
    username = $6, password_encrypted = $7, enabled = $8,
    continuous_sync = $9, post_import_action = $10, move_subfolder = $11,
    duplicate_action = $12, batch_size = $13, updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: UpdateNetworkSourceStatus :exec
UPDATE network_sources SET
    connection_state = $2, consecutive_failures = $3,
    last_sync_at = $4, last_error = $5, updated_at = NOW()
WHERE id = $1;

-- name: IncrementFilesImported :exec
UPDATE network_sources SET
    files_imported = files_imported + 1, updated_at = NOW()
WHERE id = $1;

-- name: ResetConsecutiveFailures :exec
UPDATE network_sources SET
    consecutive_failures = 0, connection_state = 'connected', updated_at = NOW()
WHERE id = $1;

-- name: IncrementConsecutiveFailures :one
UPDATE network_sources SET
    consecutive_failures = consecutive_failures + 1, updated_at = NOW()
WHERE id = $1
RETURNING consecutive_failures;

-- name: DisableNetworkSource :exec
UPDATE network_sources SET enabled = false, updated_at = NOW()
WHERE id = $1;

-- name: DeleteNetworkSource :exec
DELETE FROM network_sources WHERE id = $1;

-- name: CreateNetworkSourceEvent :one
INSERT INTO network_source_events (source_id, filename, remote_path, action, document_id, error_message)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING *;

-- name: ListNetworkSourceEvents :many
SELECT * FROM network_source_events
WHERE source_id = $1
ORDER BY created_at DESC
LIMIT $2;
```

Follow the pattern from inboxes.sql for consistency.
  </action>
  <verify>Run `make generate` and check ./tmp/air-combined.log for sqlc errors</verify>
  <done>sqlc generates Go code in internal/database/sqlc/ without errors</done>
</task>

<task type="auto">
  <name>Task 3: Create credential encryption service</name>
  <files>internal/network/crypto.go</files>
  <action>
Create the network package with credential encryption:

```go
package network

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "errors"
    "io"
)

// CredentialCrypto handles AES-256-GCM encryption for network credentials.
type CredentialCrypto struct {
    key []byte // 32 bytes derived from SESSION_SECRET
}

// NewCredentialCrypto creates a new crypto instance.
// The secret should be the SESSION_SECRET from config.
func NewCredentialCrypto(secret string) *CredentialCrypto {
    // Derive 32-byte key using SHA-256
    hash := sha256.Sum256([]byte(secret))
    return &CredentialCrypto{key: hash[:]}
}

// Encrypt encrypts plaintext using AES-256-GCM.
// Returns base64-encoded ciphertext with prepended nonce.
func (c *CredentialCrypto) Encrypt(plaintext string) (string, error) {
    if plaintext == "" {
        return "", nil
    }

    block, err := aes.NewCipher(c.key)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt decrypts base64-encoded ciphertext using AES-256-GCM.
func (c *CredentialCrypto) Decrypt(encrypted string) (string, error) {
    if encrypted == "" {
        return "", nil
    }

    data, err := base64.StdEncoding.DecodeString(encrypted)
    if err != nil {
        return "", err
    }

    block, err := aes.NewCipher(c.key)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("ciphertext too short")
    }

    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}
```

Note: Empty strings return empty (no encryption needed for NFS which has no password).
  </action>
  <verify>Check ./tmp/air-combined.log for compilation errors</verify>
  <done>CredentialCrypto compiles and provides Encrypt/Decrypt methods</done>
</task>

</tasks>

<verification>
1. Migration applies: Server starts without migration errors in ./tmp/air-combined.log
2. Sqlc generates: `make generate` produces Go types in internal/database/sqlc/
3. Crypto compiles: No errors in ./tmp/air-combined.log
4. Verify new types exist: Check for NetworkSource struct in generated code
</verification>

<success_criteria>
- network_sources table exists with all columns for SMB/NFS configuration
- network_source_events table exists for import logging
- sqlc generates all CRUD operations
- CredentialCrypto encrypts/decrypts strings using AES-256-GCM
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-network-sources/07-01-SUMMARY.md`
</output>
