---
phase: 07-network-sources
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/network/nfs.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "System can connect to NFS exports"
    - "System can list PDF files recursively in NFS exports"
    - "System can download files from NFS exports"
  artifacts:
    - path: "internal/network/nfs.go"
      provides: "NFS client implementation"
      exports: ["NFSSource", "NewNFSSource"]
  key_links:
    - from: "internal/network/nfs.go"
      to: "github.com/vmware/go-nfs-client"
      via: "go get import"
      pattern: "nfs\\.DialMount"
---

<objective>
Implement NFS client for connecting to NFS network shares.

Purpose: Users need to import documents from NFS exports (Linux servers, NAS devices). The NFS client handles connection, file listing, and download operations using NFSv3 protocol.
Output: NFSSource implementation using vmware/go-nfs-client.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-network-sources/07-RESEARCH.md
@.planning/phases/07-network-sources/07-01-SUMMARY.md
@internal/network/source.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement NFS client</name>
  <files>internal/network/nfs.go, go.mod</files>
  <action>
First, add the dependency:
```bash
go get github.com/vmware/go-nfs-client/nfs
go get github.com/vmware/go-nfs-client/nfs/rpc
```

Then create the NFS implementation:

```go
package network

import (
    "context"
    "fmt"
    "io"
    "os"
    "path/filepath"
    "strings"
    "time"

    "github.com/vmware/go-nfs-client/nfs"
    "github.com/vmware/go-nfs-client/nfs/rpc"
)

const (
    nfsConnectTimeout = 30 * time.Second
)

// NFSSource implements NetworkSource for NFSv3 shares.
type NFSSource struct {
    host       string
    exportPath string

    // Connection state
    mount  *nfs.Mount
    target *nfs.Target
}

// NewNFSSource creates a new NFS source.
// NFS typically uses AUTH_UNIX (no password), so only host and export path are needed.
func NewNFSSource(host, exportPath string) *NFSSource {
    return &NFSSource{
        host:       host,
        exportPath: exportPath,
    }
}

// connect establishes an NFS connection.
func (s *NFSSource) connect(ctx context.Context) error {
    // NFS dial with timeout via context
    mount, err := nfs.DialMount(s.host)
    if err != nil {
        return fmt.Errorf("dial mount: %w", err)
    }

    // AUTH_UNIX is standard for most NFS servers
    // Using uid/gid 0 (root) - server may remap based on exports config
    auth := rpc.NewAuthUnix("docko", 0, 0)

    target, err := mount.Mount(s.exportPath, auth)
    if err != nil {
        mount.Close()
        return fmt.Errorf("mount %s: %w", s.exportPath, err)
    }

    s.mount = mount
    s.target = target
    return nil
}

// disconnect closes the NFS connection.
func (s *NFSSource) disconnect() {
    if s.mount != nil {
        s.mount.Unmount()
        s.mount.Close()
        s.mount = nil
    }
    s.target = nil
}

// Test validates the NFS connection.
func (s *NFSSource) Test(ctx context.Context) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    // Verify we can read the root directory
    _, err := s.target.ReadDirPlus("/")
    if err != nil {
        return fmt.Errorf("read export root: %w", err)
    }
    return nil
}

// ListPDFs returns all PDF files in the export (recursive).
func (s *NFSSource) ListPDFs(ctx context.Context) ([]RemoteFile, error) {
    if err := s.connect(ctx); err != nil {
        return nil, err
    }
    defer s.disconnect()

    var files []RemoteFile
    err := s.walkDir(ctx, "/", &files)
    if err != nil {
        return nil, err
    }
    return files, nil
}

// walkDir recursively walks the directory tree.
func (s *NFSSource) walkDir(ctx context.Context, dir string, files *[]RemoteFile) error {
    // Check context for cancellation
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }

    entries, err := s.target.ReadDirPlus(dir)
    if err != nil {
        // Log and continue on errors (permission denied, etc)
        return nil
    }

    for _, entry := range entries {
        // Skip . and ..
        if entry.Name() == "." || entry.Name() == ".." {
            continue
        }

        path := filepath.Join(dir, entry.Name())

        if entry.IsDir() {
            // Recurse into subdirectories
            if err := s.walkDir(ctx, path, files); err != nil {
                return err
            }
            continue
        }

        // Only include PDF files
        if !strings.EqualFold(filepath.Ext(entry.Name()), ".pdf") {
            continue
        }

        // Get file info
        attr := entry.Attr()
        *files = append(*files, RemoteFile{
            Path:    path,
            Name:    entry.Name(),
            Size:    int64(attr.Size),
            ModTime: attr.Mtime,
        })
    }

    return nil
}

// ReadFile copies file content to the provided writer.
func (s *NFSSource) ReadFile(ctx context.Context, remotePath string, w io.Writer) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    f, err := s.target.Open(remotePath)
    if err != nil {
        return fmt.Errorf("open %s: %w", remotePath, err)
    }
    defer f.Close()

    _, err = io.Copy(w, f)
    if err != nil {
        return fmt.Errorf("copy: %w", err)
    }
    return nil
}

// DeleteFile removes a file from the export.
func (s *NFSSource) DeleteFile(ctx context.Context, remotePath string) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    if err := s.target.Remove(remotePath); err != nil {
        return fmt.Errorf("remove %s: %w", remotePath, err)
    }
    return nil
}

// MoveFile moves a file to a different path within the export.
func (s *NFSSource) MoveFile(ctx context.Context, remotePath, destPath string) error {
    if err := s.connect(ctx); err != nil {
        return err
    }
    defer s.disconnect()

    // Ensure destination directory exists
    destDir := filepath.Dir(destPath)
    if destDir != "/" && destDir != "." {
        // NFS doesn't have MkdirAll, create directories one by one
        if err := s.ensureDir(destDir); err != nil {
            return fmt.Errorf("mkdir %s: %w", destDir, err)
        }
    }

    if err := s.target.Rename(remotePath, destPath); err != nil {
        return fmt.Errorf("rename %s to %s: %w", remotePath, destPath, err)
    }
    return nil
}

// ensureDir creates directory and parents if needed.
func (s *NFSSource) ensureDir(dir string) error {
    // Split path into components
    parts := strings.Split(strings.TrimPrefix(dir, "/"), "/")
    current := ""

    for _, part := range parts {
        current = current + "/" + part

        // Try to create, ignore "exists" error
        _, err := s.target.Mkdir(current, os.FileMode(0755))
        if err != nil {
            // Check if it's an "exists" error - if so, continue
            // NFS errors are not well-typed, so we check the error message
            if !strings.Contains(err.Error(), "exist") {
                return err
            }
        }
    }
    return nil
}

// Close releases resources.
func (s *NFSSource) Close() error {
    s.disconnect()
    return nil
}
```

Key design decisions:
- Connect per operation (not persistent) - same pattern as SMB
- AUTH_UNIX authentication (standard for NFSv3)
- Manual recursive walk (go-nfs-client doesn't have WalkDir)
- 30-second connection timeout
- NFS doesn't use passwords - authentication is host-based
  </action>
  <verify>Run `go build ./...` and check ./tmp/air-combined.log for errors</verify>
  <done>NFSSource implements NetworkSource interface and compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create source factory function</name>
  <files>internal/network/source.go</files>
  <action>
Add a factory function to source.go that creates the appropriate source type based on protocol:

```go
// Add to the existing source.go file, after the interface definition:

import (
    "fmt"

    "docko/internal/database/sqlc"
)

// NewSourceFromConfig creates a NetworkSource from database configuration.
// The crypto parameter is used to decrypt passwords for SMB sources.
func NewSourceFromConfig(cfg *sqlc.NetworkSource, crypto *CredentialCrypto) (NetworkSource, error) {
    switch cfg.Protocol {
    case sqlc.NetworkProtocolSmb:
        // Decrypt password if present
        password := ""
        if cfg.PasswordEncrypted != nil && *cfg.PasswordEncrypted != "" {
            var err error
            password, err = crypto.Decrypt(*cfg.PasswordEncrypted)
            if err != nil {
                return nil, fmt.Errorf("decrypt password: %w", err)
            }
        }

        username := ""
        if cfg.Username != nil {
            username = *cfg.Username
        }

        return NewSMBSource(cfg.Host, cfg.SharePath, username, password), nil

    case sqlc.NetworkProtocolNfs:
        return NewNFSSource(cfg.Host, cfg.SharePath), nil

    default:
        return nil, fmt.Errorf("unsupported protocol: %s", cfg.Protocol)
    }
}
```

This factory:
- Takes database config and crypto service
- Decrypts SMB passwords before creating source
- Returns appropriate implementation based on protocol enum
  </action>
  <verify>Run `go build ./...` and check ./tmp/air-combined.log for errors</verify>
  <done>NewSourceFromConfig creates appropriate source type based on protocol</done>
</task>

</tasks>

<verification>
1. Dependency added: `go mod tidy` shows go-nfs-client in go.sum
2. Code compiles: `go build ./...` succeeds
3. Interface satisfied: NFSSource has all methods from NetworkSource
4. Factory works: NewSourceFromConfig returns correct type for each protocol
5. Check ./tmp/air-combined.log for any compilation errors
</verification>

<success_criteria>
- NFSSource implements all NetworkSource interface methods
- go-nfs-client dependency added to go.mod
- NewSourceFromConfig factory creates correct source type
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-network-sources/07-03-SUMMARY.md`
</output>
