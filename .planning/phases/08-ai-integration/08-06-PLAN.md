---
phase: 08-ai-integration
plan: 06
type: execute
wave: 4
depends_on: ["08-04", "08-05"]
files_modified:
  - internal/handler/documents.go
  - internal/handler/ai.go
  - templates/pages/admin/document_detail.templ
  - templates/partials/ai_suggestions.templ
autonomous: true

must_haves:
  truths:
    - "Document detail shows pending AI suggestions with inline accept/reject"
    - "User can trigger re-analyze on document detail page"
    - "Auto-applied suggestions are visible in document history"
    - "AI processing integrates with existing document workflow"
  artifacts:
    - path: "templates/partials/ai_suggestions.templ"
      provides: "AI suggestions partial for document detail"
      contains: "AISuggestions"
    - path: "internal/handler/ai.go"
      provides: "Re-analyze endpoint"
      exports: ["ReanalyzeDocument"]
  key_links:
    - from: "templates/pages/admin/document_detail.templ"
      to: "templates/partials/ai_suggestions.templ"
      via: "templ component"
      pattern: "AISuggestions"
    - from: "internal/handler/ai.go"
      to: "internal/queue/queue.go"
      via: "Enqueue"
      pattern: "queue.Enqueue"
---

<objective>
Integrate AI suggestions into document detail page with inline actions and re-analyze.

Purpose: Users need to see AI suggestions in context when viewing a document, accept or reject them inline, and trigger re-analysis. This completes the AI workflow by connecting suggestions to the document lifecycle.
Output: Document detail page with AI suggestions panel and re-analyze button.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-ai-integration/08-CONTEXT.md
@.planning/phases/08-ai-integration/08-04-SUMMARY.md
@.planning/phases/08-ai-integration/08-05-SUMMARY.md
@internal/handler/documents.go
@templates/pages/admin/document_detail.templ
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI suggestions partial</name>
  <files>templates/partials/ai_suggestions.templ</files>
  <action>
Create the AI suggestions partial for document detail:

```templ
package partials

import (
    "strconv"

    "github.com/google/uuid"
    "github.com/jackc/pgx/v5/pgtype"

    "docko/internal/database/sqlc"
)

// AISuggestions renders the AI suggestions section for a document
templ AISuggestions(docID uuid.UUID, suggestions []sqlc.AiSuggestion, aiEnabled bool) {
    <div id="ai-suggestions" class="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
            <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">AI Suggestions</h3>
            <button hx-post={ "/documents/" + docID.String() + "/analyze" }
                    hx-target="#ai-suggestions"
                    hx-swap="outerHTML"
                    hx-indicator="#analyze-spinner"
                    class="inline-flex items-center px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded transition-colors">
                <svg id="analyze-spinner" class="htmx-indicator animate-spin -ml-1 mr-2 h-4 w-4" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Re-analyze
            </button>
        </div>

        if !aiEnabled {
            <div class="p-6 text-center">
                <p class="text-gray-500 dark:text-gray-400 mb-4">AI processing is disabled</p>
                <a href="/ai" class="text-blue-600 hover:text-blue-700 dark:text-blue-400">
                    Enable in AI Settings
                </a>
            </div>
        } else if len(suggestions) == 0 {
            <div class="p-6 text-center text-gray-500 dark:text-gray-400">
                <p class="mb-2">No pending suggestions</p>
                <p class="text-sm">Click "Re-analyze" to generate new suggestions</p>
            </div>
        } else {
            <div class="divide-y divide-gray-200 dark:divide-gray-700">
                for _, s := range suggestions {
                    @suggestionItem(docID, s)
                }
            </div>
        }
    </div>
}

templ suggestionItem(docID uuid.UUID, s sqlc.AiSuggestion) {
    <div id={ "doc-suggestion-" + s.ID.String() } class="p-4 flex items-start justify-between">
        <div class="flex-1 min-w-0">
            <div class="flex items-center gap-2 mb-1">
                @suggestionTypeBadge(s.SuggestionType)
                @suggestionConfidenceBadge(s.Confidence)
                if s.IsNew {
                    <span class="text-xs text-orange-600 dark:text-orange-400">(new)</span>
                }
            </div>
            <p class="font-medium text-gray-900 dark:text-gray-100">{ s.Value }</p>
            if s.Reasoning != nil && *s.Reasoning != "" {
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">{ *s.Reasoning }</p>
            }
        </div>
        <div class="flex items-center gap-2 ml-4">
            <button hx-post={ "/ai/suggestions/" + s.ID.String() + "/accept" }
                    hx-target={ "#doc-suggestion-" + s.ID.String() }
                    hx-swap="outerHTML"
                    class="p-1.5 text-green-600 hover:bg-green-50 dark:hover:bg-green-900/20 rounded"
                    title="Accept">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
            </button>
            <button hx-post={ "/ai/suggestions/" + s.ID.String() + "/reject" }
                    hx-target={ "#doc-suggestion-" + s.ID.String() }
                    hx-swap="outerHTML"
                    class="p-1.5 text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20 rounded"
                    title="Reject">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
    </div>
}

templ suggestionTypeBadge(t sqlc.SuggestionType) {
    if t == sqlc.SuggestionTypeTag {
        <span class="inline-flex items-center px-2 py-0.5 text-xs font-medium rounded bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">
            Tag
        </span>
    } else {
        <span class="inline-flex items-center px-2 py-0.5 text-xs font-medium rounded bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200">
            Correspondent
        </span>
    }
}

templ suggestionConfidenceBadge(confidence pgtype.Numeric) {
    {{ confFloat, _ := confidence.Float64Value() }}
    {{ confPercent := int(confFloat.Float64 * 100) }}
    <span class={ "inline-flex items-center px-2 py-0.5 text-xs font-medium rounded", suggestionConfidenceClass(confFloat.Float64) }>
        { strconv.Itoa(confPercent) }%
    </span>
}

func suggestionConfidenceClass(conf float64) string {
    if conf >= 0.8 {
        return "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200"
    } else if conf >= 0.6 {
        return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200"
    }
    return "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300"
}

// SuggestionAccepted returns empty div after accepting (removes the item)
templ SuggestionAccepted() {
    <!-- Suggestion accepted and applied -->
}

// SuggestionRejected returns empty div after rejecting (removes the item)
templ SuggestionRejected() {
    <!-- Suggestion rejected -->
}
```
  </action>
  <verify>Run `make generate` and check ./tmp/air-combined.log for templ errors</verify>
  <done>AI suggestions partial compiles with inline accept/reject buttons</done>
</task>

<task type="auto">
  <name>Task 2: Add re-analyze endpoint</name>
  <files>internal/handler/ai.go</files>
  <action>
Add to internal/handler/ai.go:

```go
// ReanalyzeDocument triggers AI analysis for a document
func (h *Handler) ReanalyzeDocument(c echo.Context) error {
    ctx := c.Request().Context()

    docID, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "invalid document id")
    }

    // Check document exists
    doc, err := h.db.Queries.GetDocument(ctx, docID)
    if err != nil {
        return echo.NewHTTPError(http.StatusNotFound, "document not found")
    }

    // Check document has text content
    if doc.TextContent == nil || *doc.TextContent == "" {
        c.Response().Header().Set("HX-Trigger", `{"showToast": {"message": "Document has no text content", "type": "error"}}`)
        return h.returnSuggestionsPartial(c, docID)
    }

    // Delete existing pending suggestions for this document
    err = h.db.Queries.DeleteDocumentSuggestions(ctx, docID)
    if err != nil {
        slog.Warn("failed to delete existing suggestions", "error", err)
        // Continue anyway
    }

    // Enqueue AI analysis job
    payload := processing.AIPayload{DocumentID: docID}
    _, err = h.queue.Enqueue(ctx, "ai", "ai_analyze", payload)
    if err != nil {
        c.Response().Header().Set("HX-Trigger", `{"showToast": {"message": "Failed to queue analysis", "type": "error"}}`)
        return h.returnSuggestionsPartial(c, docID)
    }

    c.Response().Header().Set("HX-Trigger", `{"showToast": {"message": "Analysis queued", "type": "success"}}`)
    return h.returnSuggestionsPartial(c, docID)
}

// returnSuggestionsPartial returns the AI suggestions partial for a document
func (h *Handler) returnSuggestionsPartial(c echo.Context, docID uuid.UUID) error {
    ctx := c.Request().Context()

    // Get AI settings to check if enabled
    settings, err := h.aiSvc.GetSettings(ctx)
    aiEnabled := err == nil && len(h.aiSvc.AvailableProviders()) > 0

    // Get pending suggestions
    suggestions, err := h.db.Queries.ListPendingSuggestionsForDocument(ctx, docID)
    if err != nil {
        suggestions = []sqlc.AiSuggestion{}
    }

    return partials.AISuggestions(docID, suggestions, aiEnabled).Render(ctx, c.Response().Writer)
}

// ApplySuggestionManual applies a suggestion that was manually accepted
// This is exported so it can be called from other handlers
func (s *Service) ApplySuggestionManual(ctx context.Context, docID uuid.UUID, sug Suggestion) error {
    return s.applySuggestion(ctx, docID, sug)
}
```

Note: The ApplySuggestionManual method goes in internal/ai/service.go, not ai.go handler. Add export there.
  </action>
  <verify>Check ./tmp/air-combined.log for compilation errors</verify>
  <done>Re-analyze endpoint compiles and queues AI job</done>
</task>

<task type="auto">
  <name>Task 3: Integrate AI suggestions into document detail</name>
  <files>internal/handler/documents.go, templates/pages/admin/document_detail.templ</files>
  <action>
1. Update internal/handler/documents.go DocumentDetail handler to fetch AI suggestions:

Add after fetching document and before rendering:
```go
// Get AI suggestions for this document
aiSuggestions, err := h.db.Queries.ListPendingSuggestionsForDocument(ctx, docID)
if err != nil {
    aiSuggestions = []sqlc.AiSuggestion{}
}

// Check if AI is enabled (has available providers)
aiEnabled := len(h.aiSvc.AvailableProviders()) > 0
```

Pass aiSuggestions and aiEnabled to the template.

2. Update templates/pages/admin/document_detail.templ:

Add import for partials package.

Add AI suggestions section in the Overview tab, after the existing metadata sections:
```templ
<!-- AI Suggestions -->
@partials.AISuggestions(doc.ID, aiSuggestions, aiEnabled)
```

Update the templ function signature to accept aiSuggestions and aiEnabled parameters.

3. Register route in internal/handler/handler.go:
```go
// Document AI analysis route (protected)
e.POST("/documents/:id/analyze", h.ReanalyzeDocument, middleware.RequireAuth(h.auth))
```
  </action>
  <verify>Check ./tmp/air-combined.log for errors and verify document detail shows AI section</verify>
  <done>Document detail shows AI suggestions with re-analyze button</done>
</task>

<task type="auto">
  <name>Task 4: Wire AI processing into document processing pipeline</name>
  <files>internal/processing/processor.go</files>
  <action>
Update internal/processing/processor.go to optionally enqueue AI analysis after successful processing.

Add to HandleJob after successful transaction commit (after the "document processing complete" log):

```go
// Check if AI auto-processing is enabled
settings, err := p.db.Queries.GetAISettings(ctx)
if err == nil && settings.AutoProcess {
    // Enqueue AI analysis job
    aiPayload := AIPayload{DocumentID: docID}
    payloadJSON, err := json.Marshal(aiPayload)
    if err == nil {
        _, err = p.db.Queries.EnqueueJob(ctx, sqlc.EnqueueJobParams{
            QueueName: "ai",
            JobType:   "ai_analyze",
            Payload:   payloadJSON,
            Column4:   nil,
            Column5:   pgtype.Timestamptz{},
        })
        if err != nil {
            slog.Warn("failed to enqueue ai analysis", "doc_id", docID, "error", err)
        } else {
            slog.Info("ai analysis queued", "doc_id", docID)
        }
    }
}
```

This ensures that when auto_process is enabled, documents are automatically analyzed after text extraction completes.
  </action>
  <verify>Check ./tmp/air-combined.log for compilation errors</verify>
  <done>AI auto-processing wired into document pipeline</done>
</task>

</tasks>

<verification>
1. Document detail shows AI section: GET /documents/:id includes AI Suggestions panel
2. Re-analyze works: POST /documents/:id/analyze queues AI job
3. Inline accept works: Suggestion removed and applied to document
4. Inline reject works: Suggestion removed from panel
5. Auto-process works: New documents get AI job when setting enabled
6. Empty state shows: Panel shows helpful message when no suggestions
7. Disabled state shows: Panel prompts to enable when AI off
</verification>

<success_criteria>
- Document detail page has AI Suggestions section
- Re-analyze button queues AI analysis job
- Pending suggestions show with accept/reject buttons
- Accept applies suggestion (creates if new, assigns to doc)
- Reject removes suggestion
- Auto-process setting queues AI job after text extraction
- UI handles empty and disabled states gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/08-ai-integration/08-06-SUMMARY.md`
</output>
