---
phase: 14-production-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: false

must_haves:
  truths:
    - "Git history contains no accidentally committed secrets"
    - "Codebase contains no hardcoded credentials or API keys"
    - "Security scan results are documented"
  artifacts:
    - path: "gitleaks-report.json"
      provides: "Git history scan results"
      note: "Temporary file, deleted after verification"
  key_links:
    - from: "gitleaks"
      to: "git history"
      via: "secret pattern matching"
      pattern: "gitleaks git"
---

<objective>
Audit git history and codebase for accidentally committed secrets using gitleaks and manual grep patterns.

Purpose: Ensure no API keys, passwords, or credentials exist in git history or source code before production deployment.
Output: Clean security scan or documented remediation steps if secrets found.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-production-readiness/14-CONTEXT.md
@.planning/phases/14-production-readiness/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run gitleaks security scan</name>
  <files>gitleaks-report.json (temporary)</files>
  <action>
Run gitleaks to scan entire git history for secrets:

1. Install gitleaks if not available (use Docker if needed):
   - Try: `gitleaks version`
   - If not found: `docker pull ghcr.io/gitleaks/gitleaks:latest`

2. Run full git history scan:
   ```bash
   # Native installation
   gitleaks git -v --report-format json --report-path gitleaks-report.json

   # Or via Docker
   docker run --rm -v $(pwd):/repo ghcr.io/gitleaks/gitleaks:latest git -v --source=/repo --report-format json --report-path /repo/gitleaks-report.json
   ```

3. Also scan current directory (catches anything not in git):
   ```bash
   gitleaks dir -v .
   ```

4. Capture output - note if any secrets detected (exit code 1 = leaks found).

CRITICAL: Research found real OpenAI API key in .envrc - verify it was never committed. The .envrc IS in .gitignore but history may contain it.
  </action>
  <verify>
- gitleaks command completes
- Report file generated (if JSON format requested)
- Note exit code: 0 = clean, 1 = leaks found
  </verify>
  <done>
- Git history scanned with gitleaks
- Results captured (clean or leaks identified)
  </done>
</task>

<task type="auto">
  <name>Task 2: Manual codebase audit for hardcoded secrets</name>
  <files>None (read-only scan)</files>
  <action>
Grep codebase for common secret patterns to catch anything gitleaks might miss:

1. Search for hardcoded credentials:
   ```bash
   # Password patterns
   grep -rn --include="*.go" --include="*.yaml" --include="*.yml" --include="*.json" \
     -E "(password|passwd|pwd)\s*[:=]\s*['\"][^'\"]+['\"]" . | grep -v ".planning" | grep -v "_test.go"

   # API key patterns
   grep -rn --include="*.go" --include="*.yaml" --include="*.yml" --include="*.json" \
     -E "(api[_-]?key|apikey|secret[_-]?key)\s*[:=]\s*['\"][^'\"]+['\"]" . | grep -v ".planning" | grep -v "_test.go"

   # Token patterns
   grep -rn --include="*.go" --include="*.yaml" --include="*.yml" --include="*.json" \
     -E "(token|bearer)\s*[:=]\s*['\"][^'\"]+['\"]" . | grep -v ".planning" | grep -v "_test.go"
   ```

2. Check for common secret prefixes (real API keys):
   ```bash
   # OpenAI keys
   grep -rn "sk-proj-" . | grep -v ".planning" | grep -v ".envrc"
   grep -rn "sk-" . | grep -v ".planning" | grep -v ".envrc" | grep -v ".example"

   # Anthropic keys
   grep -rn "sk-ant-" . | grep -v ".planning" | grep -v ".envrc"

   # Generic secrets
   grep -rn --include="*.go" "secret\s*:=\s*\"[a-zA-Z0-9]" . | grep -v "_test.go"
   ```

3. Check docker-compose.yml for hardcoded credentials (acceptable for dev, not prod):
   - Verify dev compose uses example/default values only
   - No production secrets in any committed compose file

4. Document any findings (expected: only placeholder values like "docko" in dev compose).
  </action>
  <verify>
- Grep commands complete without finding real secrets
- Any findings are documented as false positives or issues
  </verify>
  <done>
- Manual codebase audit complete
- No hardcoded secrets in source code (or issues documented)
  </done>
</task>

<task type="checkpoint:human-verify" gate="conditional">
  <condition>Only if gitleaks or manual audit found secrets</condition>
  <what-built>Security audit completed - secrets potentially found in git history or codebase</what-built>
  <how-to-verify>
If secrets were found:

1. Review gitleaks-report.json for specific files and commits
2. Determine if secrets are:
   a) Real and active (MUST revoke immediately)
   b) Example/placeholder values (document as false positive)
   c) Historical but already rotated (document, consider history rewrite)

3. For real secrets found in history:
   - Revoke the secret immediately (API dashboard)
   - Generate new secret
   - Optionally rewrite history with git-filter-repo (see RESEARCH.md)

4. If history rewrite needed:
   ```bash
   # Backup first
   git clone --bare . ../docko-backup.git

   # Remove file from history
   git filter-repo --invert-paths --path <file-with-secret>

   # Force push (destructive!)
   git push --force --all
   ```
  </how-to-verify>
  <resume-signal>
If clean: Type "clean" - no secrets found
If secrets found and remediated: Type "remediated" and describe actions taken
If needs help: Describe what was found
  </resume-signal>
</task>

</tasks>

<verification>
- [ ] gitleaks scan completed on full git history
- [ ] gitleaks directory scan completed on current state
- [ ] Manual grep patterns found no real secrets
- [ ] docker-compose.yml contains only dev/example credentials
- [ ] Security status documented (clean or remediated)
</verification>

<success_criteria>
- Git history verified secret-free (or secrets remediated)
- Codebase contains no hardcoded credentials
- Security audit documented in SUMMARY
</success_criteria>

<output>
After completion, create `.planning/phases/14-production-readiness/14-01-SUMMARY.md`

Include:
- gitleaks scan results (clean or findings)
- Manual audit results
- Any remediation actions taken
- Confidence level in security posture
</output>
