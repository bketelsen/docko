---
phase: 14-production-readiness
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .gitignore
  - docker-compose.prod.yml
autonomous: true

must_haves:
  truths:
    - ".gitignore covers all sensitive files and build artifacts"
    - "Production Docker Compose file exists with health checks and resource limits"
    - "Production compose is standalone (no extends from dev)"
  artifacts:
    - path: ".gitignore"
      provides: "Comprehensive ignore patterns"
      contains: "*.pem"
    - path: "docker-compose.prod.yml"
      provides: "Production orchestration config"
      contains: "healthcheck"
  key_links:
    - from: "docker-compose.prod.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:"
---

<objective>
Expand .gitignore for comprehensive coverage and create standalone production Docker Compose file.

Purpose: Ensure sensitive files cannot be accidentally committed and production deployment is properly configured.
Output: Updated .gitignore and new docker-compose.prod.yml ready for production use.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-production-readiness/14-CONTEXT.md
@.planning/phases/14-production-readiness/14-RESEARCH.md
@.gitignore
@docker-compose.yml
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand .gitignore for comprehensive coverage</name>
  <files>.gitignore</files>
  <action>
Update .gitignore to include all categories of files that should never be committed.

Current .gitignore covers: binaries, build artifacts, environment files, generated files, node_modules, IDE, OS files, Tailwind output, PDFs, storage, server binary.

Add the following sections:

```gitignore
# === Secrets and credentials ===
*.pem
*.key
*.crt
*.p12
*.pfx
credentials.json
secrets.json
.secrets
*_rsa
*_dsa
*_ecdsa
*_ed25519

# === Backup files ===
*.bak
*.backup
*.sql
*.dump
backup/
backups/
*.tar.gz
*.tgz

# === Test artifacts ===
coverage/
*.coverprofile
profile.cov
coverage.*
*.test

# === Log files (supplement existing) ===
logs/

# === Editor/IDE (expand existing) ===
*.swo
*~
*.sublime-*
.project
.classpath

# === OS files (expand existing) ===
Desktop.ini
.Spotlight-V100
.Trashes
ehthumbs.db

# === Go specific ===
*.out
go.work
go.work.sum
vendor/

# === Docker ===
.docker/

# === Local development overrides ===
docker-compose.override.yml
*.local.yml
*.local.yaml

# === Security scan outputs ===
gitleaks-report.json
*.sarif
```

Preserve all existing entries. Add new sections clearly separated with comments.
  </action>
  <verify>
```bash
# Verify .gitignore is valid (no syntax errors)
git check-ignore --no-index .envrc  # Should match
git check-ignore --no-index gitleaks-report.json  # Should match after update
```
  </verify>
  <done>
- .gitignore expanded with comprehensive patterns
- All categories covered: secrets, backups, tests, logs, editors, OS, Go, Docker, local overrides, security scans
  </done>
</task>

<task type="auto">
  <name>Task 2: Create production Docker Compose file</name>
  <files>docker-compose.prod.yml</files>
  <action>
Create standalone production Docker Compose file with:
- All services (app, postgres, ocrmypdf)
- Health checks for all HTTP-capable services
- Resource limits with reasonable defaults
- JSON logging with rotation
- Named network for explicit connections
- Named volumes for persistence
- Environment variable substitution for secrets (no hardcoded values)

```yaml
# docker-compose.prod.yml
# Production deployment configuration
# Copy docker-compose.prod.yml.example and set environment variables before use

services:
  app:
    image: docko:latest
    build:
      context: .
      dockerfile: Dockerfile
    container_name: docko-app
    environment:
      - DATABASE_URL=${DATABASE_URL}
      - PORT=${PORT:-3000}
      - ENV=production
      - LOG_LEVEL=${LOG_LEVEL:-INFO}
      - SITE_NAME=${SITE_NAME:-Docko}
      - SITE_URL=${SITE_URL}
      - ADMIN_PASSWORD=${ADMIN_PASSWORD}
      - SESSION_SECRET=${SESSION_SECRET}
      - CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
      - OLLAMA_URL=${OLLAMA_URL:-}
    ports:
      - "${PORT:-3000}:3000"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "5"
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - docko-network
    volumes:
      - docko-storage:/app/storage
      - ./storage/ocr-input:/app/storage/ocr-input
      - ./storage/ocr-output:/app/storage/ocr-output

  postgres:
    image: postgres:16-alpine
    container_name: docko-postgres
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-docko}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB:-docko}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-docko} -d ${POSTGRES_DB:-docko}"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    networks:
      - docko-network
    volumes:
      - docko-postgres-data:/var/lib/postgresql/data

  ocrmypdf:
    image: jbarlow83/ocrmypdf:latest
    container_name: docko-ocrmypdf
    entrypoint: ["/bin/bash", "-c"]
    command:
      - |
        apt-get update && apt-get install -y inotify-tools &&
        mkdir -p /input /output &&
        echo 'OCRmyPDF service ready, watching /input...' &&
        while true; do
          inotifywait -q -e close_write /input/ 2>/dev/null
          for f in /input/*.pdf; do
            [ -f "$$f" ] || continue
            base=$$(basename "$$f" .pdf)
            /app/.venv/bin/ocrmypdf --skip-text --sidecar "/output/$$base.txt" -l eng "$$f" "/output/$$base.pdf" 2>&1 || true
            rm "$$f"
          done
        done
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    networks:
      - docko-network
    volumes:
      - ./storage/ocr-input:/input
      - ./storage/ocr-output:/output

networks:
  docko-network:
    name: docko-network

volumes:
  docko-postgres-data:
  docko-storage:
```

Key differences from dev compose:
- Environment variables use substitution (${VAR}) not hardcoded values
- Health checks on app container (wget to /health endpoint)
- Resource limits on all services
- JSON logging with rotation
- Named network for explicit connections
- All three services included (app, postgres, ocrmypdf)

Note: The Dockerfile already includes wget-capable alpine base, but add wget to Dockerfile if needed for health checks.
  </action>
  <verify>
```bash
# Validate compose syntax
docker compose -f docker-compose.prod.yml config --quiet && echo "Compose file valid"

# Verify required environment variables are referenced
grep -c '\${' docker-compose.prod.yml  # Should show multiple env var substitutions
```
  </verify>
  <done>
- docker-compose.prod.yml created with all services
- Health checks configured
- Resource limits set
- Logging configured with rotation
- Named network and volumes defined
  </done>
</task>

<task type="auto">
  <name>Task 3: Add wget to Dockerfile for health checks</name>
  <files>Dockerfile</files>
  <action>
Check if wget is already available in the production alpine image. If not, add it:

The current Dockerfile uses `alpine:3.21` for production and installs `ca-certificates`, `poppler-utils`, `libwebp-tools`.

Update the apk add line to include wget for health checks:

```dockerfile
RUN apk add --no-cache \
    ca-certificates \
    poppler-utils \
    libwebp-tools \
    wget
```

This ensures the health check in docker-compose.prod.yml can execute:
`wget --no-verbose --tries=1 --spider http://localhost:3000/health`

ONLY modify if wget is not already present. Check first:
```bash
docker run --rm alpine:3.21 which wget
```
(alpine base image does NOT include wget by default)
  </action>
  <verify>
```bash
# Build and verify wget is available
docker build -t docko:test . 2>&1 | tail -5
docker run --rm docko:test wget --version | head -1
```
  </verify>
  <done>
- Dockerfile includes wget for health check support
- Production image can run health check command
  </done>
</task>

</tasks>

<verification>
- [ ] .gitignore expanded with all security-relevant patterns
- [ ] docker-compose.prod.yml exists and validates
- [ ] docker-compose.prod.yml uses environment variable substitution
- [ ] Health checks configured for app and postgres
- [ ] Resource limits set for all services
- [ ] Logging configured with rotation
- [ ] Dockerfile includes wget for health checks
</verification>

<success_criteria>
- .gitignore comprehensively covers sensitive files
- docker-compose.prod.yml is standalone and production-ready
- Health check command will work in production container
</success_criteria>

<output>
After completion, create `.planning/phases/14-production-readiness/14-02-SUMMARY.md`

Include:
- .gitignore categories added
- docker-compose.prod.yml structure
- Resource limits chosen
- Any Dockerfile modifications
</output>
