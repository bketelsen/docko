---
phase: 03-processing
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - internal/handler/status.go
  - internal/handler/documents.go
  - internal/processing/status.go
  - templates/partials/document_status.templ
  - templates/partials/bulk_progress.templ
  - templates/pages/documents.templ
  - assets/js/sse.js
autonomous: false

must_haves:
  truths:
    - "User sees processing status per document (Processing/Complete/Failed)"
    - "Status updates without page refresh"
    - "Failed documents show error message"
    - "Retry button appears for failed documents and re-queues processing"
    - "Bulk uploads show summary count (3 of 10 processed)"
  artifacts:
    - path: "internal/handler/status.go"
      provides: "SSE endpoint for processing status (sends HTML partials)"
      exports: ["ProcessingStatus"]
    - path: "internal/handler/documents.go"
      provides: "Retry handler for failed documents"
      exports: ["RetryDocument"]
    - path: "internal/processing/status.go"
      provides: "Status subscription and broadcast"
      exports: ["StatusBroadcaster", "Subscribe", "Broadcast"]
    - path: "templates/partials/document_status.templ"
      provides: "Status badge component"
    - path: "templates/partials/bulk_progress.templ"
      provides: "Bulk upload progress summary"
  key_links:
    - from: "templates/pages/documents.templ"
      to: "/api/processing/status"
      via: "hx-ext=sse sse-connect"
      pattern: "sse-connect"
    - from: "internal/handler/status.go"
      to: "templates/partials/document_status.templ"
      via: "partials.DocumentStatus().Render()"
      pattern: "DocumentStatus.*Render"
    - from: "internal/handler/documents.go"
      to: "internal/queue/queue.go"
      via: "queue.Enqueue for retry"
      pattern: "Enqueue.*JobTypeProcess"
    - from: "internal/processing/processor.go"
      to: "internal/processing/status.go"
      via: "Broadcast status updates"
      pattern: "broadcaster\\.Broadcast"
---

<objective>
Implement real-time processing status updates using Server-Sent Events (SSE). Show Processing/Complete/Failed status per document with live updates. Add retry button for failed documents. Show bulk upload progress summary.

Purpose: Per CONTEXT.md requirements - users need to see processing status without refreshing the page. Provides feedback for bulk uploads and long-running OCR. Bulk uploads show summary count (3 of 10 processed) plus individual status.
Output: SSE endpoint (sends HTML partials, not JSON), status broadcaster, retry handler, status UI components with live updates, bulk progress summary
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-processing/03-RESEARCH.md
@.planning/phases/03-processing/03-CONTEXT.md
@internal/processing/processor.go
@internal/queue/queue.go
@templates/pages/admin_dashboard.templ
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement status broadcaster and SSE endpoint with HTML partials</name>
  <files>
    internal/processing/status.go
    internal/handler/status.go
  </files>
  <action>
1. Create internal/processing/status.go with StatusBroadcaster:

```go
package processing

// StatusUpdate represents a processing status change
type StatusUpdate struct {
    DocumentID uuid.UUID
    Status     string // pending, processing, completed, failed
    Error      string // error message if failed
}

// StatusBroadcaster manages SSE subscriptions for status updates
type StatusBroadcaster struct {
    subscribers map[chan StatusUpdate]struct{}
    mu          sync.RWMutex
}

// NewStatusBroadcaster creates a StatusBroadcaster
func NewStatusBroadcaster() *StatusBroadcaster

// Subscribe returns a channel that receives status updates
func (b *StatusBroadcaster) Subscribe(ctx context.Context) <-chan StatusUpdate

// Unsubscribe removes a subscription
func (b *StatusBroadcaster) Unsubscribe(ch <-chan StatusUpdate)

// Broadcast sends a status update to all subscribers
func (b *StatusBroadcaster) Broadcast(update StatusUpdate)
```

Implementation:
- Subscribe creates channel, adds to map, returns channel
- Start goroutine to remove channel when context cancelled
- Broadcast iterates subscribers, sends with select/default (non-blocking)
- Limit max subscribers to prevent resource exhaustion (e.g., 100)

2. Create internal/handler/status.go with SSE endpoint that sends HTML PARTIALS (not JSON):

```go
// ProcessingStatus handles SSE connections for processing status
// IMPORTANT: Sends rendered HTML partials, not JSON - HTMX expects HTML
func (h *Handler) ProcessingStatus(c echo.Context) error {
    w := c.Response()
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    ctx := c.Request().Context()

    updates := h.broadcaster.Subscribe(ctx)
    defer h.broadcaster.Unsubscribe(updates)

    flusher, ok := w.(http.Flusher)
    if !ok {
        return echo.NewHTTPError(http.StatusInternalServerError, "SSE not supported")
    }

    heartbeat := time.NewTicker(30 * time.Second)
    defer heartbeat.Stop()

    for {
        select {
        case <-ctx.Done():
            return nil
        case <-heartbeat.C:
            fmt.Fprintf(w, "event: heartbeat\ndata: ping\n\n")
            flusher.Flush()
        case update := <-updates:
            // CRITICAL: Render HTML partial, not JSON
            // HTMX SSE extension expects HTML content for swap
            var buf bytes.Buffer
            if err := partials.DocumentStatus(
                update.DocumentID.String(),
                update.Status,
                update.Error,
            ).Render(ctx, &buf); err != nil {
                slog.Error("failed to render status partial", "error", err)
                continue
            }

            // Event name matches sse-swap target: doc-{id}
            fmt.Fprintf(w, "event: doc-%s\ndata: %s\n\n",
                update.DocumentID.String(),
                buf.String(),
            )
            flusher.Flush()
        }
    }
}
```

3. Add route in handler setup: GET /api/processing/status

4. Update Processor to broadcast status changes:
- When processing starts: Broadcast(processing)
- When completed: Broadcast(completed)
- When failed: Broadcast(failed, error)
  </action>
  <verify>
Check ./tmp/air-combined.log for errors.
Test SSE endpoint: curl -N http://localhost:3000/api/processing/status
Should see event stream output with HTML content.
  </verify>
  <done>
StatusBroadcaster manages SSE subscriptions. SSE endpoint streams HTML partials (not JSON) for HTMX compatibility. Processor broadcasts status changes during processing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create status UI components and retry handler</name>
  <files>
    templates/partials/document_status.templ
    templates/partials/bulk_progress.templ
    templates/pages/documents.templ
    internal/handler/documents.go
  </files>
  <action>
1. Create templates/partials/document_status.templ:

```templ
// DocumentStatus renders status badge for a document
templ DocumentStatus(docID string, status string, errorMsg string) {
    <div id={ "status-" + docID } class="inline-flex items-center">
        if status == "pending" {
            <span class="px-2 py-1 text-xs rounded bg-gray-200 text-gray-700">Pending</span>
        } else if status == "processing" {
            <span class="px-2 py-1 text-xs rounded bg-blue-200 text-blue-700 animate-pulse">Processing...</span>
        } else if status == "completed" {
            <span class="px-2 py-1 text-xs rounded bg-green-200 text-green-700">Complete</span>
        } else if status == "failed" {
            <span class="px-2 py-1 text-xs rounded bg-red-200 text-red-700">Failed</span>
            if errorMsg != "" {
                <span class="ml-1 text-xs text-red-600" title={ errorMsg }>(?)</span>
            }
            <button
                hx-post={ "/api/documents/" + docID + "/retry" }
                hx-swap="outerHTML"
                hx-target={ "#status-" + docID }
                class="ml-2 text-xs text-blue-600 hover:underline"
            >Retry</button>
        }
    </div>
}
```

2. Create templates/partials/bulk_progress.templ for bulk upload summary (per CONTEXT.md: "Bulk uploads show summary count (3 of 10 processed)"):

```templ
// BulkProgress renders aggregate progress for bulk uploads
templ BulkProgress(processed int, total int) {
    <div id="bulk-progress" class="text-sm text-gray-600">
        if total > 1 {
            <span>{ fmt.Sprintf("%d of %d processed", processed, total) }</span>
            if processed < total {
                <span class="ml-2 animate-pulse">Processing...</span>
            } else {
                <span class="ml-2 text-green-600">Complete</span>
            }
        }
    </div>
}
```

3. Create or update templates/pages/documents.templ:
- Document list page showing all documents
- Each document row shows: filename, size, date, status badge
- Connect to SSE for live updates with HTML swap:

```templ
<div hx-ext="sse" sse-connect="/api/processing/status">
    // Bulk progress summary (updates via SSE event "bulk-progress")
    <div sse-swap="bulk-progress" hx-swap="innerHTML">
        @BulkProgress(processedCount, totalCount)
    </div>

    for _, doc := range documents {
        <div class="document-row">
            // ... filename, size, date ...

            // Status badge - swapped by SSE event "doc-{id}"
            <div sse-swap={ "doc-" + doc.ID.String() } hx-swap="innerHTML">
                @DocumentStatus(doc.ID.String(), string(doc.ProcessingStatus), doc.ProcessingError)
            </div>
        </div>
    }
</div>
```

4. Implement retry handler in internal/handler/documents.go:

```go
// RetryDocument re-queues a failed document for processing
// POST /api/documents/:id/retry
func (h *Handler) RetryDocument(c echo.Context) error {
    docID, err := uuid.Parse(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "invalid document ID")
    }

    // Reset status to pending
    if err := h.db.Queries.SetDocumentProcessingStatus(c.Request().Context(),
        sqlc.SetDocumentProcessingStatusParams{
            ID:               docID,
            ProcessingStatus: "pending",
        }); err != nil {
        return echo.NewHTTPError(http.StatusInternalServerError, "failed to reset status")
    }

    // Re-enqueue processing job
    payload := document.IngestPayload{DocumentID: docID}
    payloadBytes, _ := json.Marshal(payload)
    if err := h.queue.Enqueue(c.Request().Context(), document.JobTypeProcess, payloadBytes); err != nil {
        return echo.NewHTTPError(http.StatusInternalServerError, "failed to enqueue")
    }

    // Return updated status partial
    return partials.DocumentStatus(docID.String(), "pending", "").
        Render(c.Request().Context(), c.Response().Writer)
}
```

5. Add route: POST /api/documents/:id/retry

6. Update SSE handler to also broadcast bulk progress when processing completes:
- Query current processed/total counts
- Send "bulk-progress" event with rendered BulkProgress partial

7. Add HTMX SSE extension if not already included:
- Add sse extension to assets/js or CDN link in base layout
  </action>
  <verify>
Check ./tmp/air-combined.log for errors.
Run: make dev
Navigate to documents page and verify status badges appear.
Upload a document and watch status update from Pending -> Processing -> Complete.
Test retry: if a document fails, click retry and verify it re-queues.
  </verify>
  <done>
Status UI shows Processing/Complete/Failed per document. Live updates via SSE with HTML partials. Retry button re-queues failed documents via POST /api/documents/:id/retry. Bulk progress shows "3 of 10 processed" summary. HTMX SSE integration working.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete processing pipeline with real-time status updates</what-built>
  <how-to-verify>
1. Start the app: make dev
2. Navigate to http://localhost:3000/admin/documents (or document list page)
3. Upload a PDF via web UI
4. Watch the status badge update:
   - Should show "Processing..." (with animation)
   - After processing completes: "Complete" (green badge)
5. Test bulk upload:
   - Upload multiple PDFs at once
   - Verify bulk progress shows "X of Y processed"
   - Watch individual statuses update
6. Test failure case (if possible):
   - Upload a password-protected PDF or corrupt file
   - After retries exhaust: "Failed" with retry button
7. Click retry button - should re-queue processing and show "Pending"
8. Check logs for processing activity (text extraction, thumbnail)
  </how-to-verify>
  <resume-signal>Type "approved" if processing status works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] SSE endpoint streams HTML partials (not JSON)
- [ ] partials.DocumentStatus().Render() called in SSE handler
- [ ] Status badge shows correct state (Pending/Processing/Complete/Failed)
- [ ] Live updates work without page refresh
- [ ] Failed documents show error and retry button
- [ ] Retry button calls POST /api/documents/:id/retry
- [ ] Retry handler re-enqueues job via queue.Enqueue
- [ ] Bulk progress shows "X of Y processed" summary
- [ ] HTMX SSE extension properly integrated
</verification>

<success_criteria>
Users can see real-time processing status for documents. Upload shows immediate feedback as documents move through the processing pipeline. Failed documents can be retried via dedicated endpoint. Bulk uploads show aggregate progress count. Complete user feedback loop for document processing.
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing/03-05-SUMMARY.md`
</output>
