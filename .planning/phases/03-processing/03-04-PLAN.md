---
phase: 03-processing
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - internal/processing/processor.go
  - internal/processing/processor_test.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Processing job handler orchestrates text + thumbnail extraction"
    - "Both text AND thumbnail must succeed (all-or-nothing)"
    - "Failed processing retries 3x with backoff"
    - "Processing runs asynchronously via queue"
    - "Quarantine handles repeated failures"
  artifacts:
    - path: "internal/processing/processor.go"
      provides: "Processing job handler and orchestration"
      exports: ["Processor", "HandleJob"]
    - path: "internal/processing/processor_test.go"
      provides: "Tests for processing orchestration"
  key_links:
    - from: "internal/processing/processor.go"
      to: "internal/queue/queue.go"
      via: "RegisterHandler for JobTypeProcess"
      pattern: "RegisterHandler.*process_document"
    - from: "internal/processing/processor.go"
      to: "internal/document/document.go"
      via: "document.Service for paths and events"
      pattern: "docSvc\\.OriginalPath"
    - from: "cmd/server/main.go"
      to: "internal/processing/processor.go"
      via: "queue.Start after handler registration"
      pattern: "processor.*RegisterHandler"
---

<objective>
Implement the processing job handler that orchestrates text extraction and thumbnail generation. Wire it to the queue system and start processing uploaded documents.

Purpose: Complete the async processing pipeline. When documents are uploaded, the queue picks them up and processes them in the background without blocking the upload.
Output: Processing job handler registered with queue, processing starts automatically for uploaded documents
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-processing/03-RESEARCH.md
@.planning/phases/03-processing/03-01-SUMMARY.md
@internal/queue/queue.go
@internal/document/document.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement processing job handler</name>
  <files>
    internal/processing/processor.go
  </files>
  <action>
Create internal/processing/processor.go with Processor:

```go
package processing

// Processor orchestrates document processing (text + thumbnail)
type Processor struct {
    db          *database.DB
    docSvc      *document.Service
    textExt     *TextExtractor
    thumbGen    *ThumbnailGenerator
    storage     *storage.Storage
}

// New creates a new Processor
func New(db *database.DB, docSvc *document.Service, storage *storage.Storage, placeholderPath string) *Processor

// HandleJob processes a document (implements queue.JobHandler)
func (p *Processor) HandleJob(ctx context.Context, job *sqlc.Job) error

// quarantine moves a document to quarantine after repeated failures
func (p *Processor) quarantine(ctx context.Context, docID uuid.UUID, reason string) error
```

Implementation per RESEARCH.md and CONTEXT.md:

1. HandleJob():
   - Parse job payload to get DocumentID
   - Get document from docSvc
   - Update status to 'processing'
   - Extract text using textExt.Extract()
   - Generate thumbnail using thumbGen.Generate()
   - If BOTH succeed:
     * Start transaction
     * Update document with text_content, processing_status='completed', thumbnail_generated=true
     * Log success event
     * Commit
   - If EITHER fails:
     * Return error (queue will retry with backoff)
     * Job exhausts retries after 3 attempts (max_attempts default in job creation)
     * On final failure: quarantine document, set processing_status='failed'

2. All-or-nothing transaction pattern:
   ```go
   tx, err := p.db.Pool.Begin(ctx)
   defer tx.Rollback(ctx)
   qtx := p.db.Queries.WithTx(tx)
   // ... all updates ...
   return tx.Commit(ctx)
   ```

3. Quarantine:
   - Set processing_status='failed', processing_error=reason
   - Log 'quarantined' event with error details
   - Consider moving file to quarantine folder (optional, can defer)
  </action>
  <verify>
Check ./tmp/air-combined.log for compilation errors.
Run: go build ./internal/processing/...
  </verify>
  <done>
Processing job handler orchestrates text extraction and thumbnail generation. All-or-nothing ensures both succeed. Quarantine handles repeated failures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire processor to queue and start workers</name>
  <files>
    cmd/server/main.go
    internal/processing/processor_test.go
  </files>
  <action>
1. Update cmd/server/main.go to:
   - Create Processor after document service and queue are initialized
   - Register handler: queue.RegisterHandler(document.JobTypeProcess, processor.HandleJob)
   - Start queue workers: queue.Start(ctx, document.QueueDefault)
   - Ensure graceful shutdown calls queue.Stop()

   Example initialization order:
   ```go
   // After storage, db, queue, docSvc are created...
   processor := processing.New(db, docSvc, storage, "static/images/placeholder.webp")
   queue.RegisterHandler(document.JobTypeProcess, processor.HandleJob)
   queue.Start(ctx, document.QueueDefault)

   // In shutdown...
   queue.Stop()
   ```

2. Check dependencies on startup:
   ```go
   if err := processing.CheckDependencies(); err != nil {
       slog.Warn("processing dependencies missing", "error", err)
       // Don't fatal - app can run, just processing will fail
   }
   ```

3. Create processor_test.go:
   - Test HandleJob with mock document service
   - Test all-or-nothing: if text succeeds but thumbnail fails, document stays pending
   - Test quarantine is called after max attempts exhausted
   - Test successful processing updates all fields

Note: The queue Start was deferred in Phase 1 because no handlers were registered. Now we register and start.
  </action>
  <verify>
Check ./tmp/air-combined.log for errors.
Run: make dev and check logs for "queue starting" message.
Upload a PDF and check logs for processing activity.
Run: make test to verify tests pass.
  </verify>
  <done>
Queue workers started with process_document handler. Uploaded documents are automatically processed in background. Processing status updates in database.
  </done>
</task>

</tasks>

<verification>
- [ ] internal/processing/processor.go compiles without errors
- [ ] Handler registered with queue for "process_document" job type
- [ ] Queue workers start on application startup
- [ ] Uploading a PDF triggers background processing
- [ ] Processing updates document status in database
- [ ] Tests verify processing logic
</verification>

<success_criteria>
End-to-end processing works: Upload PDF -> Queue job created -> Worker picks up job -> Text extracted -> Thumbnail generated -> Document marked complete. Failed processing retries and eventually quarantines.
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing/03-04-SUMMARY.md`
</output>
