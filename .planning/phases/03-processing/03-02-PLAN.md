---
phase: 03-processing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/processing/text.go
  - internal/processing/text_test.go
autonomous: true

must_haves:
  truths:
    - "Text can be extracted from PDFs with embedded text"
    - "Scanned PDFs are processed with OCR"
    - "OCR only runs when embedded text is insufficient"
  artifacts:
    - path: "internal/processing/text.go"
      provides: "Text extraction with embedded + OCR fallback"
      exports: ["TextExtractor", "Extract"]
    - path: "internal/processing/text_test.go"
      provides: "Tests for text extraction"
  key_links:
    - from: "internal/processing/text.go"
      to: "ledongthuc/pdf"
      via: "import and pdf.Open"
      pattern: "pdf\\.Open"
    - from: "internal/processing/text.go"
      to: "docker-compose ocrmypdf service"
      via: "shared volume (ocr-input/ocr-output)"
      pattern: "ocr-input|ocr-output"
---

<objective>
Implement text extraction service that extracts embedded text from PDFs using ledongthuc/pdf library, falling back to the OCRmyPDF Docker service (via shared volumes) for scanned documents.

Purpose: Enable full-text search (Phase 6) by extracting searchable text from all PDF types - both native PDFs with embedded text and scanned image PDFs requiring OCR.
Output: Text extraction service with hybrid approach (embedded first, OCR fallback via service)
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-processing/03-RESEARCH.md
@.planning/phases/03-processing/03-CONTEXT.md
@internal/document/document.go
@internal/storage/storage.go
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement embedded text extraction</name>
  <files>
    internal/processing/text.go
  </files>
  <action>
Create internal/processing/text.go with TextExtractor:

```go
package processing

// TextExtractor extracts text from PDF files
type TextExtractor struct {
    minTextLength int    // Minimum chars to consider "has text" (default: 100)
    ocrInputPath  string // Path to ocr-input volume mount
    ocrOutputPath string // Path to ocr-output volume mount
}

// NewTextExtractor creates a TextExtractor
// ocrInputPath and ocrOutputPath are the mount points for the OCRmyPDF service volumes
func NewTextExtractor(ocrInputPath, ocrOutputPath string) *TextExtractor

// Extract extracts text from a PDF file
// Returns: text content, method used ("embedded" or "ocr"), error
func (e *TextExtractor) Extract(ctx context.Context, pdfPath string) (string, string, error)

// extractEmbedded attempts to extract embedded text using ledongthuc/pdf
// Returns: text, hasText (len > minTextLength), error
func (e *TextExtractor) extractEmbedded(pdfPath string) (string, bool, error)
```

Implementation details:
1. Use github.com/ledongthuc/pdf for embedded text extraction:
   ```go
   f, r, err := pdf.Open(pdfPath)
   defer f.Close()
   reader, err := r.GetPlainText()
   buf.ReadFrom(reader)
   ```

2. In Extract():
   - Try extractEmbedded first
   - If hasText (len >= minTextLength), return embedded text
   - Otherwise fall back to OCR (implemented in Task 2)

3. Add go get github.com/ledongthuc/pdf

4. Log extraction method and text length using slog
  </action>
  <verify>
Check ./tmp/air-combined.log for compilation errors.
Run: go build ./internal/processing/...
  </verify>
  <done>
TextExtractor can extract embedded text from PDFs. Returns text content and extraction method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OCR fallback via OCRmyPDF service</name>
  <files>
    internal/processing/text.go
    internal/processing/text_test.go
  </files>
  <action>
Add OCR fallback to text.go using the persistent OCRmyPDF Docker service (NOT ephemeral docker run).

Per CONTEXT.md decision: "Use Tesseract via Docker service (similar to existing postgres container)"

```go
// ocrViaService sends PDF to OCRmyPDF service and retrieves extracted text
// Uses shared volumes configured in docker-compose.yml
func (e *TextExtractor) ocrViaService(ctx context.Context, pdfPath string) (string, error)
```

Implementation using shared volumes (ocr-input, ocr-output):

1. Generate unique job ID (e.g., UUID or timestamp+random)

2. Copy PDF to ocr-input volume:
   ```go
   jobID := uuid.New().String()
   inputPath := filepath.Join(e.ocrInputPath, jobID+".pdf")
   if err := copyFile(pdfPath, inputPath); err != nil {
       return "", fmt.Errorf("copy to ocr input: %w", err)
   }
   ```

3. Wait for output in ocr-output volume (the service watches /input and writes to /output):
   ```go
   outputTextPath := filepath.Join(e.ocrOutputPath, jobID+".txt")

   // Poll for output with timeout (5 minutes per RESEARCH.md)
   ticker := time.NewTicker(500 * time.Millisecond)
   defer ticker.Stop()
   timeout := time.After(5 * time.Minute)

   for {
       select {
       case <-ctx.Done():
           return "", ctx.Err()
       case <-timeout:
           return "", fmt.Errorf("OCR timeout waiting for output")
       case <-ticker.C:
           if _, err := os.Stat(outputTextPath); err == nil {
               // Output ready, read it
               text, err := os.ReadFile(outputTextPath)
               if err != nil {
                   return "", fmt.Errorf("read OCR output: %w", err)
               }
               // Clean up output files
               os.Remove(outputTextPath)
               os.Remove(filepath.Join(e.ocrOutputPath, jobID+".pdf"))
               return string(text), nil
           }
       }
   }
   ```

4. Read the sidecar text file from ocr-output

5. Clean up output files after reading

IMPORTANT: Do NOT use `docker run --rm` for OCR. The OCRmyPDF service is already running as a persistent container (configured in 03-01). We communicate via shared volumes.

Update Extract() to call ocrViaService when embedded text insufficient.

Create text_test.go with tests:
1. Test extractEmbedded with mock/sample PDF (or skip if no test PDF)
2. Test that Extract returns "embedded" method when text sufficient
3. Test ocrViaService file handling (can use temp directories to simulate)
  </action>
  <verify>
Check ./tmp/air-combined.log for errors.
Run: make test to verify tests pass.
Verify OCRmyPDF service is running: docker compose ps
  </verify>
  <done>
Text extraction handles both embedded text and OCR fallback. OCR uses the persistent OCRmyPDF Docker service via shared volumes (NOT ephemeral docker run). Tests verify extraction logic.
  </done>
</task>

</tasks>

<verification>
- [ ] internal/processing/text.go compiles without errors
- [ ] TextExtractor.Extract() returns text and method
- [ ] Embedded extraction uses ledongthuc/pdf
- [ ] OCR fallback communicates with OCRmyPDF service via shared volumes
- [ ] NO usage of `docker run` or `exec.Command("docker", ...)` for OCR
- [ ] Tests exist and pass
- [ ] Proper error handling and logging
</verification>

<success_criteria>
Text extraction service complete. Can extract text from PDFs with embedded text quickly, falls back to OCRmyPDF service (via shared volumes) for scanned documents. Honors user decision to use Tesseract via Docker service. Ready to be used by processing job handler.
</success_criteria>

<output>
After completion, create `.planning/phases/03-processing/03-02-SUMMARY.md`
</output>
