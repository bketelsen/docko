---
phase: 05-organization
plan: 03
type: execute
wave: 2
depends_on: ["05-02"]
files_modified:
  - sqlc/queries/correspondents.sql
  - internal/handler/correspondents.go
  - templates/pages/admin/correspondents.templ
autonomous: true

must_haves:
  truths:
    - "User can select multiple correspondents for merging"
    - "User can choose a target correspondent to merge into"
    - "User can execute merge and all documents reassign to target"
    - "Merged correspondent notes are appended to target"
  artifacts:
    - path: "sqlc/queries/correspondents.sql"
      provides: "Merge queries for correspondent consolidation"
      contains: "MergeCorrespondentsUpdateDocs"
    - path: "internal/handler/correspondents.go"
      provides: "Merge handler"
      exports: ["MergeCorrespondents"]
    - path: "templates/pages/admin/correspondents.templ"
      provides: "Merge UI with selection and confirmation"
      contains: "merge-mode"
  key_links:
    - from: "templates/pages/admin/correspondents.templ"
      to: "internal/handler/correspondents.go"
      via: "HTMX merge form post"
      pattern: "hx-post.*correspondents/merge"
    - from: "internal/handler/correspondents.go"
      to: "database transaction"
      via: "WithTx for atomic merge"
      pattern: "WithTx|BeginTx"
---

<objective>
Implement correspondent merge functionality.

Purpose: Allow users to consolidate duplicate correspondents by merging multiple correspondents into one target. All documents from merged correspondents are reassigned to the target, and notes from merged correspondents are appended to the target's notes.

Output: Merge UI in correspondent management page with multi-select, target selection, and atomic merge operation.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-organization/05-CONTEXT.md
@.planning/phases/05-organization/05-RESEARCH.md

# Depends on Plan 02 outputs
@.planning/phases/05-organization/05-02-SUMMARY.md

# Pattern reference
@internal/handler/correspondents.go
@templates/pages/admin/correspondents.templ
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add merge SQL queries</name>
  <files>sqlc/queries/correspondents.sql</files>
  <action>
Add merge-related queries to sqlc/queries/correspondents.sql:

1. `MergeCorrespondentsUpdateDocs` - Update all document_correspondents to point to target:
   ```sql
   -- name: MergeCorrespondentsUpdateDocs :exec
   UPDATE document_correspondents
   SET correspondent_id = $1
   WHERE correspondent_id = ANY($2::uuid[]);
   ```

2. `GetCorrespondentsNotes` - Get notes from multiple correspondents for appending:
   ```sql
   -- name: GetCorrespondentsNotes :many
   SELECT id, name, notes FROM correspondents
   WHERE id = ANY($1::uuid[]) AND notes IS NOT NULL AND notes != '';
   ```

3. `AppendCorrespondentNotes` - Append notes to target correspondent:
   ```sql
   -- name: AppendCorrespondentNotes :one
   UPDATE correspondents
   SET notes = CASE
       WHEN notes IS NULL OR notes = '' THEN $2
       ELSE notes || E'\n---\n' || $2
   END
   WHERE id = $1
   RETURNING *;
   ```

4. `DeleteCorrespondentsByIds` - Delete multiple correspondents by ID array:
   ```sql
   -- name: DeleteCorrespondentsByIds :exec
   DELETE FROM correspondents WHERE id = ANY($1::uuid[]);
   ```

Note: The merge operation requires a transaction to ensure atomicity. The handler will use db.WithTx or manual transaction management.
  </action>
  <verify>Run `make generate` and check `./tmp/air-combined.log` for sqlc errors. Verify new query functions are generated.</verify>
  <done>Merge queries compile without errors and generated Go code includes all 4 new functions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement merge handler with transaction</name>
  <files>internal/handler/correspondents.go</files>
  <action>
Add MergeCorrespondents handler to internal/handler/correspondents.go:

1. Parse form data:
   - `target_id` - UUID of correspondent to merge INTO
   - `merge_ids` - Array of UUIDs to merge (will be deleted)

2. Validate:
   - target_id is valid UUID
   - merge_ids contains at least one valid UUID
   - target_id is NOT in merge_ids (can't merge into itself)

3. Execute merge in transaction:
   ```go
   tx, err := h.db.Pool.Begin(ctx)
   if err != nil { return error }
   defer tx.Rollback(ctx)

   qtx := h.db.Queries.WithTx(tx)

   // Step 1: Update document references
   err = qtx.MergeCorrespondentsUpdateDocs(ctx, sqlc.MergeCorrespondentsUpdateDocsParams{
       CorrespondentID: targetID,
       Column2: mergeIDs,
   })

   // Step 2: Get notes from merged correspondents
   notesToMerge, err := qtx.GetCorrespondentsNotes(ctx, mergeIDs)

   // Step 3: Append notes to target (if any)
   if len(notesToMerge) > 0 {
       var combinedNotes strings.Builder
       for _, n := range notesToMerge {
           combinedNotes.WriteString(fmt.Sprintf("--- Merged from %s ---\n%s\n", n.Name, *n.Notes))
       }
       _, err = qtx.AppendCorrespondentNotes(ctx, sqlc.AppendCorrespondentNotesParams{
           ID: targetID,
           Column2: combinedNotes.String(),
       })
   }

   // Step 4: Delete merged correspondents
   err = qtx.DeleteCorrespondentsByIds(ctx, mergeIDs)

   // Commit
   err = tx.Commit(ctx)
   ```

4. Return response:
   - On success: Return updated correspondent list HTML for full list replacement
   - On error: Return 400/500 with error message

Register route:
- POST /correspondents/merge -> MergeCorrespondents
  </action>
  <verify>Run `make dev`, check `./tmp/air-combined.log` for compilation errors. Verify route is registered.</verify>
  <done>Merge handler compiles, uses transaction, and route is registered.</done>
</task>

<task type="auto">
  <name>Task 3: Add merge UI to correspondent management page</name>
  <files>templates/pages/admin/correspondents.templ</files>
  <action>
Enhance templates/pages/admin/correspondents.templ with merge functionality:

1. Add "Merge Mode" toggle button in page header:
   - Button toggles merge-mode class on page container
   - Shows/hides merge-related UI elements

2. Update CorrespondentCard to include checkbox:
   - Checkbox visible only when merge mode active (CSS: .merge-mode .merge-checkbox { display: block })
   - Checkbox name="merge_ids" value={correspondent.ID}
   - Checkbox in a form that wraps the entire correspondent list

3. Add merge action bar (visible only in merge mode):
   - Shows count of selected correspondents
   - Target selector dropdown (select one correspondent as merge target)
   - "Merge Selected" button
   - "Cancel" button to exit merge mode

4. Merge form structure:
   ```html
   <form id="merge-form" hx-post="/correspondents/merge" hx-target="#correspondent-list" hx-swap="innerHTML">
     <input type="hidden" name="target_id" id="merge-target"/>
     <!-- Checkboxes in cards provide merge_ids -->
     <div class="merge-bar hidden merge-mode:flex ...">
       <span id="merge-count">0 selected</span>
       <select id="target-select" onchange="document.getElementById('merge-target').value = this.value">
         <option value="">Select target...</option>
         for _, c := range correspondents {
           <option value={c.ID.String()}>{c.Name}</option>
         }
       </select>
       <button type="submit" disabled id="merge-btn">Merge into Target</button>
       <button type="button" onclick="exitMergeMode()">Cancel</button>
     </div>
   </form>
   ```

5. Add JavaScript for merge mode:
   - Toggle merge mode class on container
   - Update selected count when checkboxes change
   - Enable/disable merge button based on: target selected AND at least 2 checkboxes checked
   - Ensure target is not in selected merge_ids (disable that checkbox or show warning)

6. Confirmation dialog before merge:
   - Use hx-confirm with message showing count and target name
   - "Merge X correspondents into {target name}? This cannot be undone."
  </action>
  <verify>Run `make dev`, navigate to /correspondents. Test merge mode toggle, checkbox selection, and target selection. Create 3 test correspondents, select 2, merge into third.</verify>
  <done>Merge UI works: can enter merge mode, select correspondents, choose target, and execute merge. Documents reassigned and merged correspondents deleted.</done>
</task>

</tasks>

<verification>
1. Create 3 correspondents: "Acme", "ACME Corp", "Acme Inc"
2. Click "Merge Mode" button - checkboxes appear on cards
3. Select "ACME Corp" and "Acme Inc" checkboxes
4. Select "Acme" as merge target
5. Click "Merge into Target" - confirm dialog appears
6. Confirm merge - list updates, only "Acme" remains
7. Check "Acme" notes - should contain notes from merged correspondents (if any had notes)
8. Exit merge mode - checkboxes hidden
</verification>

<success_criteria>
- Merge mode can be toggled on/off
- Can select multiple correspondents via checkboxes
- Can select target correspondent (not from selected list)
- Merge operation is atomic (all or nothing)
- Document references updated to target
- Notes from merged correspondents appended to target
- Merged correspondents deleted
- UI updates after merge without full page reload
- Confirmation dialog prevents accidental merges
</success_criteria>

<output>
After completion, create `.planning/phases/05-organization/05-03-SUMMARY.md`
</output>
