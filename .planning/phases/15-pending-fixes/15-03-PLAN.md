---
phase: 15-pending-fixes
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - internal/database/migrations/012_job_current_step.sql
  - sqlc/queries/jobs.sql
  - internal/processing/status.go
  - internal/processing/processor.go
autonomous: true

must_haves:
  truths:
    - "Jobs table has current_step column to track processing progress"
    - "Processor updates current_step before each processing phase"
    - "SSE StatusUpdate includes current step information"
    - "Stuck jobs are identifiable via started_at timestamp"
  artifacts:
    - path: "internal/database/migrations/012_job_current_step.sql"
      provides: "Database schema for current_step column"
      contains: "current_step"
    - path: "sqlc/queries/jobs.sql"
      provides: "Query to update job step"
      contains: "UpdateJobStep"
    - path: "internal/processing/status.go"
      provides: "Extended StatusUpdate struct with CurrentStep"
      contains: "CurrentStep"
    - path: "internal/processing/processor.go"
      provides: "Step updates at each processing phase"
      contains: "StepExtractingText"
  key_links:
    - from: "internal/processing/processor.go"
      to: "internal/processing/status.go"
      via: "StatusUpdate broadcast"
      pattern: "StatusUpdate.*CurrentStep"
---

<objective>
Add processing progress visibility by tracking current step in database and broadcasting via SSE.

Purpose: Users currently see only "processing" status with no indication of which step is active or if a job is stuck. Step-level visibility helps diagnose issues and set expectations.

Output: Jobs track current step (starting, extracting_text, running_ocr, generating_thumbnail, finalizing), SSE broadcasts include step info.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-pending-fixes/15-RESEARCH.md
@internal/database/migrations/003_documents.sql
@internal/processing/processor.go
@internal/processing/status.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add current_step column to jobs table</name>
  <files>internal/database/migrations/012_job_current_step.sql</files>
  <action>
    Create migration file to add current_step column:

    ```sql
    -- +goose Up
    ALTER TABLE jobs ADD COLUMN current_step VARCHAR(50);
    -- Allowed values: 'starting', 'extracting_text', 'running_ocr', 'generating_thumbnail', 'finalizing'
    -- NULL indicates job hasn't started processing

    -- +goose Down
    ALTER TABLE jobs DROP COLUMN IF EXISTS current_step;
    ```

    Note: Using VARCHAR instead of ENUM for flexibility in adding new steps without migration.
  </action>
  <verify>
    - File exists: `ls internal/database/migrations/012_job_current_step.sql`
    - Migration syntax valid: Check `./tmp/air-combined.log` after restart
  </verify>
  <done>Migration adds current_step column to jobs table</done>
</task>

<task type="auto">
  <name>Task 2: Add UpdateJobStep sqlc query</name>
  <files>sqlc/queries/jobs.sql</files>
  <action>
    Add query to update the current step for a job:

    ```sql
    -- name: UpdateJobStep :exec
    UPDATE jobs
    SET current_step = $2, updated_at = NOW()
    WHERE id = $1;
    ```

    After adding, sqlc generate will run automatically via `make dev`.
  </action>
  <verify>
    - Check `./tmp/air-combined.log` for sqlc generation success
    - Verify generated code: `grep -c "UpdateJobStep" internal/database/sqlc/jobs.sql.go`
  </verify>
  <done>UpdateJobStep query allows setting current processing step</done>
</task>

<task type="auto">
  <name>Task 3: Extend StatusUpdate with CurrentStep and add step constants</name>
  <files>internal/processing/status.go</files>
  <action>
    1. Add step constants after the status constants:
       ```go
       // Processing step constants for progress tracking
       const (
           StepStarting            = "starting"
           StepExtractingText      = "extracting_text"
           StepRunningOCR          = "running_ocr"
           StepGeneratingThumbnail = "generating_thumbnail"
           StepFinalizing          = "finalizing"
       )
       ```

    2. Add CurrentStep field to StatusUpdate struct:
       ```go
       // StatusUpdate represents a processing status change
       type StatusUpdate struct {
           DocumentID  uuid.UUID
           Status      string // pending, processing, completed, failed
           CurrentStep string // starting, extracting_text, running_ocr, generating_thumbnail, finalizing
           Error       string // error message if failed
           QueueName   string // queue name for queue-level SSE events
       }
       ```
  </action>
  <verify>
    - Check `./tmp/air-combined.log` for compilation errors
    - Verify constants: `grep -c "StepExtractingText" internal/processing/status.go`
    - Verify struct field: `grep -c "CurrentStep.*string" internal/processing/status.go`
  </verify>
  <done>StatusUpdate includes CurrentStep field and step constants are defined</done>
</task>

<task type="auto">
  <name>Task 4: Update processor to track and broadcast steps</name>
  <files>internal/processing/processor.go</files>
  <action>
    1. Add a helper method to update step and broadcast:
       ```go
       // updateStep updates the job's current step in database and broadcasts to SSE
       func (p *Processor) updateStep(ctx context.Context, jobID, docID uuid.UUID, step string) {
           // Update database
           if err := p.db.Queries.UpdateJobStep(ctx, sqlc.UpdateJobStepParams{
               ID:          jobID,
               CurrentStep: &step,
           }); err != nil {
               slog.Warn("failed to update job step", "job_id", jobID, "step", step, "error", err)
           }

           // Broadcast to SSE subscribers
           p.broadcast(StatusUpdate{
               DocumentID:  docID,
               Status:      StatusProcessing,
               CurrentStep: step,
               QueueName:   document.QueueDefault,
           })
       }
       ```

    2. In HandleJob, add step updates at each phase:

       After setting status to 'processing':
       ```go
       // Update step: starting
       p.updateStep(ctx, job.ID, docID, StepStarting)
       ```

       Before text extraction:
       ```go
       // Update step: extracting text
       p.updateStep(ctx, job.ID, docID, StepExtractingText)
       ```

       Inside text extraction (if OCR path is taken, textExt.Extract can log internally):
       Note: OCR step would be tracked inside TextExtractor if needed, but for simplicity,
       extracting_text covers both embedded and OCR paths.

       Before thumbnail generation:
       ```go
       // Update step: generating thumbnail
       p.updateStep(ctx, job.ID, docID, StepGeneratingThumbnail)
       ```

       Before transaction commit:
       ```go
       // Update step: finalizing
       p.updateStep(ctx, job.ID, docID, StepFinalizing)
       ```

    3. Update the existing broadcast calls to include empty CurrentStep for completed/failed states:
       ```go
       p.broadcast(StatusUpdate{
           DocumentID:  docID,
           Status:      StatusCompleted,
           CurrentStep: "", // Cleared on completion
           QueueName:   document.QueueDefault,
       })
       ```
  </action>
  <verify>
    - Check `./tmp/air-combined.log` for compilation errors
    - Verify updateStep method: `grep -c "func.*updateStep" internal/processing/processor.go`
    - Verify step calls: `grep -c "p.updateStep" internal/processing/processor.go`
  </verify>
  <done>Processor updates current_step at each processing phase and broadcasts to SSE</done>
</task>

</tasks>

<verification>
1. Check build logs: `cat ./tmp/air-combined.log` - no errors
2. Verify migration: `ls internal/database/migrations/012_job_current_step.sql`
3. Verify sqlc query: `grep "UpdateJobStep" sqlc/queries/jobs.sql`
4. Verify code changes:
   - `grep -c "StepExtractingText" internal/processing/status.go` returns >= 1
   - `grep -c "CurrentStep" internal/processing/status.go` returns >= 2
   - `grep -c "updateStep" internal/processing/processor.go` returns >= 4
5. Run tests: `make test`
</verification>

<success_criteria>
- Migration adds current_step column to jobs table
- UpdateJobStep query is generated by sqlc
- StatusUpdate struct has CurrentStep field
- Processor calls updateStep before each processing phase
- Application compiles and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-pending-fixes/15-03-SUMMARY.md`
</output>
