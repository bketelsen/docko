---
phase: 06-search
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/handler/documents.go
  - templates/partials/search_results.templ
autonomous: true

must_haves:
  truths:
    - "Handler parses search parameters from URL query string"
    - "HTMX requests return partial, direct requests return full page"
    - "Search results include headline snippets when query provided"
  artifacts:
    - path: "internal/handler/documents.go"
      provides: "Search parameter parsing and SearchDocuments query call"
      contains: "SearchDocuments"
    - path: "templates/partials/search_results.templ"
      provides: "Document results partial for HTMX swapping"
      contains: "SearchResults"
  key_links:
    - from: "internal/handler/documents.go"
      to: "SearchDocuments query"
      via: "h.db.Queries.SearchDocuments"
      pattern: "SearchDocuments"
    - from: "internal/handler/documents.go"
      to: "HX-Request header"
      via: "HTMX detection"
      pattern: "HX-Request"
---

<objective>
Wire up the search handler to call SearchDocuments and return appropriate responses for HTMX vs full page requests.

Purpose: Connect the database search layer to the web layer, enabling search from URL parameters.
Output: Handler that parses search params and returns either partial or full page; results partial template.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-search/06-CONTEXT.md
@.planning/phases/06-search/06-RESEARCH.md
@.planning/phases/06-search/06-01-SUMMARY.md
@internal/handler/documents.go
@templates/pages/admin/documents.templ
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search results partial template</name>
  <files>templates/partials/search_results.templ</files>
  <action>
Create a new partial template for search results that can be swapped by HTMX.

The partial should:
1. Display results in the same table format as existing Documents page
2. Include headline snippet with highlighted matches when available
3. Show match reason indicator ("Matched: content" or "Matched: correspondent" etc)
4. Handle empty results with helpful message
5. Include pagination controls

```templ
package partials

import (
    "docko/internal/database/sqlc"
    "docko/templates/pages/admin"
    "github.com/google/uuid"
    "fmt"
)

// SearchResult wraps document with search metadata
type SearchResult struct {
    sqlc.Document
    CorrespondentID   *uuid.UUID
    CorrespondentName *string
    Rank              float64
    Headline          string
}

// SearchParams holds parsed search parameters for template rendering
type SearchParams struct {
    Query           string
    CorrespondentID string
    TagIDs          []string
    DateRange       string
    Page            int
    PerPage         int
}

// ActiveFilter represents a filter chip to display
type ActiveFilter struct {
    Type    string // "query", "correspondent", "tag", "date"
    Label   string
    Value   string
    RemoveURL string
}

templ SearchResults(results []SearchResult, docTags admin.DocumentTagsMap, docCorrespondents admin.DocumentCorrespondentMap, params SearchParams, totalCount int, activeFilters []ActiveFilter) {
    // Active filter chips
    if len(activeFilters) > 0 {
        <div id="active-filters" class="flex flex-wrap gap-2 mb-4">
            for _, filter := range activeFilters {
                <span class="inline-flex items-center gap-1 px-3 py-1 bg-muted rounded-full text-sm">
                    <span class="text-muted-foreground">{ filter.Type }:</span>
                    <span>{ filter.Label }</span>
                    <button
                        hx-get={ filter.RemoveURL }
                        hx-target="#document-results"
                        hx-push-url="true"
                        class="ml-1 text-muted-foreground hover:text-foreground"
                    >
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </span>
            }
            if len(activeFilters) > 1 {
                <button
                    hx-get="/documents"
                    hx-target="#document-results"
                    hx-push-url="true"
                    class="text-sm text-muted-foreground hover:text-foreground underline"
                >
                    Clear all
                </button>
            }
        </div>
    }

    // Results count
    <div class="text-sm text-muted-foreground mb-4">
        if totalCount == 0 {
            No documents found
        } else if totalCount == 1 {
            1 document
        } else {
            { fmt.Sprintf("%d documents", totalCount) }
        }
        if params.Query != "" {
            { fmt.Sprintf(" matching \"%s\"", params.Query) }
        }
    </div>

    if len(results) == 0 {
        @emptySearchResults(params, activeFilters)
    } else {
        <div class="border border-border rounded-lg overflow-hidden">
            <table class="w-full">
                <thead class="bg-muted/50">
                    <tr>
                        <th class="px-4 py-3 text-left text-sm font-medium">Document</th>
                        <th class="px-4 py-3 text-left text-sm font-medium">Tags</th>
                        <th class="px-4 py-3 text-left text-sm font-medium">Correspondent</th>
                        <th class="px-4 py-3 text-left text-sm font-medium">Date</th>
                        <th class="px-4 py-3 text-left text-sm font-medium">Status</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-border">
                    for _, result := range results {
                        <tr class="hover:bg-muted/30">
                            <td class="px-4 py-3">
                                <div class="flex items-start gap-3">
                                    <svg class="w-8 h-8 text-red-500 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"></path>
                                        <path fill="white" d="M14 2v6h6"></path>
                                        <text x="7" y="17" fill="white" font-size="6" font-weight="bold">PDF</text>
                                    </svg>
                                    <div class="min-w-0">
                                        <a href={ templ.SafeURL("/documents/" + result.ID.String()) }
                                           class="block truncate hover:text-primary hover:underline font-medium"
                                           title={ result.OriginalFilename }>
                                            { result.OriginalFilename }
                                        </a>
                                        if result.Headline != "" {
                                            <p class="text-sm text-muted-foreground mt-1 line-clamp-2">
                                                @templ.Raw(result.Headline)
                                            </p>
                                        }
                                        if params.Query != "" {
                                            <span class="text-xs text-muted-foreground">Matched: content</span>
                                        }
                                    </div>
                                </div>
                            </td>
                            <td class="px-4 py-3">
                                @InlineTagPicker(result.ID.String(), getResultTags(docTags, result.ID))
                            </td>
                            <td class="px-4 py-3">
                                @InlineCorrespondentDisplay(getResultCorrespondent(result))
                            </td>
                            <td class="px-4 py-3 text-sm text-muted-foreground">
                                { formatDocDate(result.DocumentDate) }
                            </td>
                            <td class="px-4 py-3">
                                @DocumentStatus(result.ID.String(), string(result.ProcessingStatus), derefStrPtr(result.ProcessingError))
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>

        // Pagination
        if totalCount > params.PerPage {
            @searchPagination(params, totalCount)
        }
    }
}

templ emptySearchResults(params SearchParams, activeFilters []ActiveFilter) {
    <div class="border border-border rounded-lg p-8 text-center">
        <svg class="w-12 h-12 mx-auto text-muted-foreground mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
        </svg>
        if len(activeFilters) > 0 {
            <p class="text-lg font-medium mb-2">No documents match your filters</p>
            <p class="text-muted-foreground mb-4">
                Try removing some filters or adjusting your search.
            </p>
            <button
                hx-get="/documents"
                hx-target="#document-results"
                hx-push-url="true"
                class="inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
            >
                Clear all filters
            </button>
        } else {
            <p class="text-lg font-medium mb-2">No documents yet</p>
            <p class="text-muted-foreground mb-4">Upload your first document to get started.</p>
            <a href="/upload" class="inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90">
                Upload Document
            </a>
        }
    </div>
}

templ searchPagination(params SearchParams, totalCount int) {
    // Calculate pagination
    {{
        totalPages := (totalCount + params.PerPage - 1) / params.PerPage
        currentPage := params.Page
        if currentPage < 1 {
            currentPage = 1
        }
    }}
    <div class="flex items-center justify-between mt-4 px-2">
        <div class="text-sm text-muted-foreground">
            {{
                start := (currentPage - 1) * params.PerPage + 1
                end := currentPage * params.PerPage
                if end > totalCount {
                    end = totalCount
                }
            }}
            Showing { fmt.Sprintf("%d-%d", start, end) } of { fmt.Sprintf("%d", totalCount) }
        </div>
        <div class="flex gap-1">
            if currentPage > 1 {
                <button
                    hx-get={ buildPaginationURL(params, currentPage-1) }
                    hx-target="#document-results"
                    hx-push-url="true"
                    class="px-3 py-1 text-sm border border-border rounded hover:bg-muted"
                >
                    Previous
                </button>
            }
            if currentPage < totalPages {
                <button
                    hx-get={ buildPaginationURL(params, currentPage+1) }
                    hx-target="#document-results"
                    hx-push-url="true"
                    class="px-3 py-1 text-sm border border-border rounded hover:bg-muted"
                >
                    Next
                </button>
            }
        </div>
    </div>
}

// Helper functions
func getResultTags(docTags admin.DocumentTagsMap, docID uuid.UUID) []sqlc.Tag {
    if docTags == nil {
        return []sqlc.Tag{}
    }
    tags, ok := docTags[docID]
    if !ok {
        return []sqlc.Tag{}
    }
    return tags
}

func getResultCorrespondent(result SearchResult) *string {
    return result.CorrespondentName
}

func formatDocDate(t time.Time) string {
    return t.Format("Jan 2, 2006")
}

func derefStrPtr(s *string) string {
    if s == nil {
        return ""
    }
    return *s
}

func buildPaginationURL(params SearchParams, page int) string {
    // Build URL with all current params plus new page
    url := fmt.Sprintf("/documents?page=%d", page)
    if params.Query != "" {
        url += "&q=" + params.Query
    }
    if params.CorrespondentID != "" {
        url += "&correspondent=" + params.CorrespondentID
    }
    if params.DateRange != "" {
        url += "&date=" + params.DateRange
    }
    for _, tagID := range params.TagIDs {
        url += "&tag=" + tagID
    }
    return url
}
```

Add import for "time" at the top. The partial reuses existing InlineTagPicker, InlineCorrespondentDisplay, and DocumentStatus partials.
  </action>
  <verify>Run `make dev` and check `./tmp/air-combined.log` for successful templ generation. Verify `templates/partials/search_results_templ.go` exists.</verify>
  <done>SearchResults partial template created with results table, filter chips, empty states, and pagination</done>
</task>

<task type="auto">
  <name>Task 2: Update DocumentsPage handler with search support</name>
  <files>internal/handler/documents.go</files>
  <action>
Update the DocumentsPage handler to:
1. Parse search parameters from URL query string
2. Call SearchDocuments query with filters
3. Detect HTMX requests via HX-Request header
4. Return partial for HTMX, full page for direct requests
5. Build active filters list for display

Add a SearchParams struct and helper functions for parsing:

```go
// Add to imports
import (
    "net/url"
    "strconv"
    "strings"
    "time"
)

// SearchParams holds parsed search parameters
type SearchParams struct {
    Query           string
    CorrespondentID *uuid.UUID
    TagIDs          []uuid.UUID
    DateFrom        *time.Time
    DateTo          *time.Time
    DateRange       string  // Original value: "today", "7d", "30d", "1y"
    Page            int
    PerPage         int
}

// parseSearchParams extracts search parameters from request
func parseSearchParams(c echo.Context) SearchParams {
    params := SearchParams{
        Query:     strings.TrimSpace(c.QueryParam("q")),
        DateRange: c.QueryParam("date"),
        Page:      1,
        PerPage:   20,
    }

    // Parse page number
    if p := c.QueryParam("page"); p != "" {
        if page, err := strconv.Atoi(p); err == nil && page > 0 {
            params.Page = page
        }
    }

    // Parse correspondent filter
    if corrID := c.QueryParam("correspondent"); corrID != "" {
        if id, err := uuid.Parse(corrID); err == nil {
            params.CorrespondentID = &id
        }
    }

    // Parse tag filters (multiple allowed)
    for _, tagID := range c.QueryParams()["tag"] {
        if id, err := uuid.Parse(tagID); err == nil {
            params.TagIDs = append(params.TagIDs, id)
        }
    }

    // Parse date range
    now := time.Now()
    switch params.DateRange {
    case "today":
        start := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
        params.DateFrom = &start
    case "7d":
        start := now.AddDate(0, 0, -7)
        params.DateFrom = &start
    case "30d":
        start := now.AddDate(0, 0, -30)
        params.DateFrom = &start
    case "1y":
        start := now.AddDate(-1, 0, 0)
        params.DateFrom = &start
    }

    return params
}

// buildActiveFilters creates filter chip data from params
func buildActiveFilters(params SearchParams, correspondentName string, tagNames map[uuid.UUID]string) []partials.ActiveFilter {
    var filters []partials.ActiveFilter
    baseURL := "/documents?"

    // Build base params (for removal URLs)
    buildURL := func(exclude string) string {
        var parts []string
        if params.Query != "" && exclude != "query" {
            parts = append(parts, "q="+url.QueryEscape(params.Query))
        }
        if params.CorrespondentID != nil && exclude != "correspondent" {
            parts = append(parts, "correspondent="+params.CorrespondentID.String())
        }
        if params.DateRange != "" && exclude != "date" {
            parts = append(parts, "date="+params.DateRange)
        }
        for _, tagID := range params.TagIDs {
            if exclude != "tag-"+tagID.String() {
                parts = append(parts, "tag="+tagID.String())
            }
        }
        if len(parts) == 0 {
            return "/documents"
        }
        return baseURL + strings.Join(parts, "&")
    }

    if params.Query != "" {
        filters = append(filters, partials.ActiveFilter{
            Type:      "Search",
            Label:     params.Query,
            Value:     params.Query,
            RemoveURL: buildURL("query"),
        })
    }

    if params.CorrespondentID != nil && correspondentName != "" {
        filters = append(filters, partials.ActiveFilter{
            Type:      "Correspondent",
            Label:     correspondentName,
            Value:     params.CorrespondentID.String(),
            RemoveURL: buildURL("correspondent"),
        })
    }

    if params.DateRange != "" {
        labels := map[string]string{
            "today": "Today",
            "7d":    "Last 7 days",
            "30d":   "Last 30 days",
            "1y":    "Last year",
        }
        filters = append(filters, partials.ActiveFilter{
            Type:      "Date",
            Label:     labels[params.DateRange],
            Value:     params.DateRange,
            RemoveURL: buildURL("date"),
        })
    }

    for _, tagID := range params.TagIDs {
        if name, ok := tagNames[tagID]; ok {
            filters = append(filters, partials.ActiveFilter{
                Type:      "Tag",
                Label:     name,
                Value:     tagID.String(),
                RemoveURL: buildURL("tag-" + tagID.String()),
            })
        }
    }

    return filters
}
```

Update DocumentsPage to use search:

```go
func (h *Handler) DocumentsPage(c echo.Context) error {
    ctx := c.Request().Context()
    params := parseSearchParams(c)

    // Build query parameters
    var query *string
    if params.Query != "" {
        query = &params.Query
    }

    var correspondentID uuid.UUID
    hasCorrespondent := params.CorrespondentID != nil
    if hasCorrespondent {
        correspondentID = *params.CorrespondentID
    }

    var dateFrom, dateTo time.Time
    hasDateFrom := params.DateFrom != nil
    hasDateTo := params.DateTo != nil
    if hasDateFrom {
        dateFrom = *params.DateFrom
    }
    if hasDateTo {
        dateTo = *params.DateTo
    }

    hasTags := len(params.TagIDs) > 0
    tagCount := int32(len(params.TagIDs))

    // Execute search
    rows, err := h.db.Queries.SearchDocuments(ctx, sqlc.SearchDocumentsParams{
        Query:            query,
        HasCorrespondent: hasCorrespondent,
        CorrespondentID:  correspondentID,
        HasDateFrom:      hasDateFrom,
        DateFrom:         dateFrom,
        HasDateTo:        hasDateTo,
        DateTo:           dateTo,
        HasTags:          hasTags,
        TagIds:           params.TagIDs,
        TagCount:         tagCount,
        LimitCount:       int32(params.PerPage),
        OffsetCount:      int32((params.Page - 1) * params.PerPage),
    })
    if err != nil {
        return echo.NewHTTPError(http.StatusInternalServerError, "search failed")
    }

    // Get total count for pagination
    total, err := h.db.Queries.CountSearchDocuments(ctx, sqlc.CountSearchDocumentsParams{
        Query:            query,
        HasCorrespondent: hasCorrespondent,
        CorrespondentID:  correspondentID,
        HasDateFrom:      hasDateFrom,
        DateFrom:         dateFrom,
        HasDateTo:        hasDateTo,
        DateTo:           dateTo,
        HasTags:          hasTags,
        TagIds:           params.TagIDs,
        TagCount:         tagCount,
    })
    if err != nil {
        total = 0 // Non-fatal, just show results
    }

    // Convert rows to SearchResult
    results := make([]partials.SearchResult, len(rows))
    docIDs := make([]uuid.UUID, len(rows))
    for i, row := range rows {
        results[i] = partials.SearchResult{
            Document: sqlc.Document{
                ID:                 row.ID,
                OriginalFilename:   row.OriginalFilename,
                ContentHash:        row.ContentHash,
                FileSize:           row.FileSize,
                PageCount:          row.PageCount,
                PdfTitle:           row.PdfTitle,
                PdfAuthor:          row.PdfAuthor,
                PdfCreatedAt:       row.PdfCreatedAt,
                DocumentDate:       row.DocumentDate,
                CreatedAt:          row.CreatedAt,
                UpdatedAt:          row.UpdatedAt,
                ProcessingStatus:   row.ProcessingStatus,
                TextContent:        row.TextContent,
                ThumbnailGenerated: row.ThumbnailGenerated,
                ProcessingError:    row.ProcessingError,
                ProcessedAt:        row.ProcessedAt,
            },
            CorrespondentID:   row.CorrespondentID,
            CorrespondentName: row.CorrespondentName,
            Rank:              row.Rank,
            Headline:          row.Headline,
        }
        docIDs[i] = row.ID
    }

    // Fetch tags for results
    docTags := make(admin.DocumentTagsMap)
    if len(docIDs) > 0 {
        tagRows, err := h.db.Queries.GetTagsForDocuments(ctx, docIDs)
        if err == nil {
            for _, row := range tagRows {
                tag := sqlc.Tag{ID: row.ID, Name: row.Name, Color: row.Color, CreatedAt: row.CreatedAt}
                docTags[row.DocumentID] = append(docTags[row.DocumentID], tag)
            }
        }
    }

    // Build correspondents map
    docCorrespondents := make(admin.DocumentCorrespondentMap)
    for _, result := range results {
        if result.CorrespondentName != nil {
            docCorrespondents[result.ID] = *result.CorrespondentName
        }
    }

    // Get correspondent name for filter chip
    var correspondentName string
    if params.CorrespondentID != nil {
        if corr, err := h.db.Queries.GetCorrespondent(ctx, *params.CorrespondentID); err == nil {
            correspondentName = corr.Name
        }
    }

    // Get tag names for filter chips
    tagNames := make(map[uuid.UUID]string)
    for _, tagID := range params.TagIDs {
        if tag, err := h.db.Queries.GetTag(ctx, tagID); err == nil {
            tagNames[tagID] = tag.Name
        }
    }

    activeFilters := buildActiveFilters(params, correspondentName, tagNames)

    // Convert params for template
    templateParams := partials.SearchParams{
        Query:           params.Query,
        DateRange:       params.DateRange,
        Page:            params.Page,
        PerPage:         params.PerPage,
    }
    if params.CorrespondentID != nil {
        templateParams.CorrespondentID = params.CorrespondentID.String()
    }
    for _, tagID := range params.TagIDs {
        templateParams.TagIDs = append(templateParams.TagIDs, tagID.String())
    }

    // Check if HTMX request (return partial) or full page
    if c.Request().Header.Get("HX-Request") == "true" {
        return partials.SearchResults(results, docTags, docCorrespondents, templateParams, int(total), activeFilters).
            Render(ctx, c.Response().Writer)
    }

    // Full page - need to render Documents template with search form
    // Pass results to Documents template (will update in next plan)
    return admin.DocumentsWithSearch(results, docTags, docCorrespondents, templateParams, int(total), activeFilters).
        Render(ctx, c.Response().Writer)
}
```

Note: This references admin.DocumentsWithSearch which will be created in Plan 03. For now, create a simple wrapper that calls the partial within the layout.
  </action>
  <verify>Run `make dev` and check `./tmp/air-combined.log` for successful compilation. Test by visiting `/documents?q=test` - should execute search query without errors.</verify>
  <done>Handler parses all search params, calls SearchDocuments, returns partial for HTMX or full page for direct requests</done>
</task>

</tasks>

<verification>
1. No compilation errors in `./tmp/air-combined.log`
2. Visit `/documents` - shows all documents (no filter)
3. Visit `/documents?q=test` - executes search, shows filtered results
4. View page source or network tab - search_vector query is used
5. Test HTMX behavior by inspecting network requests with HX-Request header
</verification>

<success_criteria>
- SearchResults partial renders document table with headline snippets
- Handler parses q, correspondent, tag, date, page params from URL
- Empty query returns all documents
- HTMX requests (HX-Request header) return just the partial
- Direct browser requests return full page
- Active filter chips display with removal URLs
- Pagination shows correct totals and page controls
</success_criteria>

<output>
After completion, create `.planning/phases/06-search/06-02-SUMMARY.md`
</output>
