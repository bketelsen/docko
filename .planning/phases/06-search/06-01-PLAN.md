---
phase: 06-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/database/migrations/007_search_vector.sql
  - sqlc/queries/documents.sql
autonomous: true

must_haves:
  truths:
    - "Full-text search query matches document content"
    - "Filters combine correctly with AND logic"
    - "Empty query returns all documents"
  artifacts:
    - path: "internal/database/migrations/007_search_vector.sql"
      provides: "search_vector column and GIN index"
      contains: "CREATE INDEX.*GIN.*search_vector"
    - path: "sqlc/queries/documents.sql"
      provides: "SearchDocuments query"
      contains: "SearchDocuments"
  key_links:
    - from: "sqlc/queries/documents.sql"
      to: "search_vector column"
      via: "websearch_to_tsquery"
      pattern: "websearch_to_tsquery"
---

<objective>
Add PostgreSQL full-text search infrastructure to the documents table.

Purpose: Enable fast, indexed full-text search on document content and filenames.
Output: Database migration adding search_vector column with GIN index, and SearchDocuments query with optional filters.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-search/06-CONTEXT.md
@.planning/phases/06-search/06-RESEARCH.md
@internal/database/migrations/005_processing.sql
@sqlc/queries/documents.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add search_vector column and GIN index migration</name>
  <files>internal/database/migrations/007_search_vector.sql</files>
  <action>
Create a new goose migration that:

1. Adds a generated tsvector column to documents table:
```sql
ALTER TABLE documents
    ADD COLUMN search_vector tsvector
    GENERATED ALWAYS AS (
        to_tsvector('english',
            coalesce(original_filename, '') || ' ' ||
            coalesce(text_content, '')
        )
    ) STORED;
```

2. Creates a GIN index for fast full-text search:
```sql
CREATE INDEX idx_documents_search ON documents USING GIN (search_vector);
```

The generated column automatically updates when original_filename or text_content changes.
Use coalesce to handle NULL values (prevents NULL propagation).
  </action>
  <verify>Run `make dev` and check `./tmp/air-combined.log` for successful migration. Verify column exists with: `docker compose exec postgres psql -U docko -c "\d documents" | grep search_vector`</verify>
  <done>search_vector column exists as generated tsvector, GIN index created</done>
</task>

<task type="auto">
  <name>Task 2: Create SearchDocuments query with filters</name>
  <files>sqlc/queries/documents.sql</files>
  <action>
Add a new SearchDocuments query to documents.sql that supports:
- Optional full-text search (empty string = no filter)
- Optional correspondent filter
- Optional tag filter (AND logic - must have ALL selected tags)
- Optional date range filter
- Pagination with limit/offset
- Returns search rank and headline snippet when query is provided

Use the boolean flag pattern for optional filters (sqlc doesn't support dynamic WHERE):

```sql
-- name: SearchDocuments :many
SELECT
    d.*,
    c.id as correspondent_id,
    c.name as correspondent_name,
    CASE WHEN sqlc.narg(query)::text IS NOT NULL AND sqlc.narg(query)::text != ''
         THEN ts_rank(d.search_vector, websearch_to_tsquery('english', sqlc.narg(query)::text))
         ELSE 0 END as rank,
    CASE WHEN sqlc.narg(query)::text IS NOT NULL AND sqlc.narg(query)::text != ''
         THEN ts_headline('english', COALESCE(d.text_content, ''), websearch_to_tsquery('english', sqlc.narg(query)::text),
              'MaxFragments=1, MaxWords=30, MinWords=15, StartSel=<mark>, StopSel=</mark>')
         ELSE '' END as headline
FROM documents d
LEFT JOIN document_correspondents dc ON dc.document_id = d.id
LEFT JOIN correspondents c ON c.id = dc.correspondent_id
WHERE
    -- Full-text search (optional - empty/null matches all)
    (sqlc.narg(query)::text IS NULL OR sqlc.narg(query)::text = ''
        OR d.search_vector @@ websearch_to_tsquery('english', sqlc.narg(query)::text))
    -- Correspondent filter (optional)
    AND (NOT sqlc.arg(has_correspondent)::boolean OR c.id = sqlc.arg(correspondent_id)::uuid)
    -- Date range filter (optional)
    AND (NOT sqlc.arg(has_date_from)::boolean OR d.document_date >= sqlc.arg(date_from)::timestamptz)
    AND (NOT sqlc.arg(has_date_to)::boolean OR d.document_date <= sqlc.arg(date_to)::timestamptz)
    -- Tag filter (optional - AND logic: must have ALL selected tags)
    AND (NOT sqlc.arg(has_tags)::boolean
        OR d.id IN (
            SELECT dt.document_id
            FROM document_tags dt
            WHERE dt.tag_id = ANY(sqlc.arg(tag_ids)::uuid[])
            GROUP BY dt.document_id
            HAVING COUNT(DISTINCT dt.tag_id) = sqlc.arg(tag_count)::int
        ))
ORDER BY
    CASE WHEN sqlc.narg(query)::text IS NOT NULL AND sqlc.narg(query)::text != ''
         THEN ts_rank(d.search_vector, websearch_to_tsquery('english', sqlc.narg(query)::text))
         ELSE 0 END DESC,
    d.document_date DESC NULLS LAST
LIMIT sqlc.arg(limit_count) OFFSET sqlc.arg(offset_count);
```

Also add a count query for pagination:

```sql
-- name: CountSearchDocuments :one
SELECT COUNT(*)::int as total
FROM documents d
LEFT JOIN document_correspondents dc ON dc.document_id = d.id
LEFT JOIN correspondents c ON c.id = dc.correspondent_id
WHERE
    (sqlc.narg(query)::text IS NULL OR sqlc.narg(query)::text = ''
        OR d.search_vector @@ websearch_to_tsquery('english', sqlc.narg(query)::text))
    AND (NOT sqlc.arg(has_correspondent)::boolean OR c.id = sqlc.arg(correspondent_id)::uuid)
    AND (NOT sqlc.arg(has_date_from)::boolean OR d.document_date >= sqlc.arg(date_from)::timestamptz)
    AND (NOT sqlc.arg(has_date_to)::boolean OR d.document_date <= sqlc.arg(date_to)::timestamptz)
    AND (NOT sqlc.arg(has_tags)::boolean
        OR d.id IN (
            SELECT dt.document_id
            FROM document_tags dt
            WHERE dt.tag_id = ANY(sqlc.arg(tag_ids)::uuid[])
            GROUP BY dt.document_id
            HAVING COUNT(DISTINCT dt.tag_id) = sqlc.arg(tag_count)::int
        ));
```

Key points:
- websearch_to_tsquery handles user input safely (no syntax errors)
- ts_headline only computed when query provided (performance)
- Boolean flags enable/disable each filter
- Tag filtering uses subquery with HAVING to enforce AND logic
- Always specify 'english' for consistent text search config
  </action>
  <verify>Run `make dev` and check `./tmp/air-combined.log` for successful sqlc generation. Verify `internal/database/sqlc/documents.sql.go` contains SearchDocuments and CountSearchDocuments functions.</verify>
  <done>SearchDocuments query generated with all filter options, CountSearchDocuments for pagination totals</done>
</task>

</tasks>

<verification>
1. Migration applied: `docker compose exec postgres psql -U docko -c "\d documents"` shows search_vector column
2. Index exists: `docker compose exec postgres psql -U docko -c "\di idx_documents_search"` shows GIN index
3. sqlc generated: `internal/database/sqlc/documents.sql.go` contains SearchDocuments and CountSearchDocuments
4. No compilation errors in `./tmp/air-combined.log`
</verification>

<success_criteria>
- search_vector column exists as GENERATED ALWAYS tsvector STORED
- GIN index idx_documents_search created on search_vector
- SearchDocuments query accepts optional query, correspondent, tags, date range filters
- CountSearchDocuments query returns total count for pagination
- Empty query returns all documents (no filter)
- All sqlc types generated correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-search/06-01-SUMMARY.md`
</output>
