---
phase: 11-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - internal/handler/admin.go
autonomous: true

must_haves:
  truths:
    - "Dashboard handler aggregates all stats into single struct"
    - "Handler passes DashboardData to template"
    - "Errors are handled gracefully with default values"
  artifacts:
    - path: "internal/handler/admin.go"
      provides: "Dashboard data aggregation handler"
      contains: "DashboardData"
  key_links:
    - from: "internal/handler/admin.go"
      to: "internal/database/sqlc/dashboard.sql.go"
      via: "h.db.Queries.GetDashboardDocumentStats"
      pattern: "GetDashboard"
    - from: "internal/handler/admin.go"
      to: "templates/pages/admin/dashboard.templ"
      via: "admin.Dashboard(data)"
      pattern: "Dashboard\\(data\\)"
---

<objective>
Create DashboardData struct and update handler to aggregate all dashboard statistics.

Purpose: Single point of data aggregation before passing to template, following existing QueueDashboardPage pattern.
Output: Updated admin.go with DashboardData type and handler that fetches all dashboard stats.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-dashboard/11-CONTEXT.md
@.planning/phases/11-dashboard/11-RESEARCH.md
@internal/handler/admin.go
@internal/handler/ai.go
@internal/database/sqlc/dashboard.sql.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DashboardData struct and update handler</name>
  <files>internal/handler/admin.go</files>
  <action>
Update `internal/handler/admin.go` to:

1. Add DashboardData struct with nested types for clean organization:

```go
// DashboardData holds all stats for the main dashboard
type DashboardData struct {
    // Documents section
    Documents struct {
        Total     int64
        Processed int64
        Pending   int64
        Failed    int64
        Today     int64
    }
    TagCount         int64
    CorrespondentCount int64

    // Processing section
    Processing struct {
        Pending    int64
        Processing int64
        Completed  int64
        Failed     int64
        Health     string // "healthy", "warning", "issues"
    }
    PendingSuggestions int64
    RecentJobs         []sqlc.Job
    ActiveProvider     string
    JobsToday          int64

    // Sources section
    Inboxes struct {
        Total   int64
        Enabled int64
    }
    NetworkSources struct {
        Total   int64
        Enabled int64
    }
}
```

2. Add helper function for queue health calculation:

```go
func calculateQueueHealth(pending, failed int64) string {
    if failed > 0 {
        return "issues"
    }
    if pending >= 10 {
        return "warning"
    }
    return "healthy"
}
```

3. Add helper function to get active AI provider:

```go
func (h *Handler) getActiveProvider(ctx context.Context) string {
    settings, err := h.db.Queries.GetAISettings(ctx)
    if err != nil {
        return "None"
    }
    if settings.PreferredProvider != "" {
        return settings.PreferredProvider
    }
    return "Auto"
}
```

4. Update AdminDashboard handler to aggregate all data:

```go
func (h *Handler) AdminDashboard(c echo.Context) error {
    ctx := c.Request().Context()
    data := DashboardData{}

    // Documents section
    if docStats, err := h.db.Queries.GetDashboardDocumentStats(ctx); err == nil {
        data.Documents.Total = docStats.Total
        data.Documents.Processed = docStats.Processed
        data.Documents.Pending = docStats.Pending
        data.Documents.Failed = docStats.Failed
        data.Documents.Today = docStats.Today
    }

    if tagCount, err := h.db.Queries.CountTags(ctx); err == nil {
        data.TagCount = tagCount
    }

    if corrCount, err := h.db.Queries.CountCorrespondents(ctx); err == nil {
        data.CorrespondentCount = corrCount
    }

    // Processing section
    if queueStats, err := h.db.Queries.GetDashboardQueueStats(ctx); err == nil {
        data.Processing.Pending = queueStats.Pending
        data.Processing.Processing = queueStats.Processing
        data.Processing.Completed = queueStats.Completed
        data.Processing.Failed = queueStats.Failed
        data.Processing.Health = calculateQueueHealth(queueStats.Pending, queueStats.Failed)
    }

    if pendingSugg, err := h.db.Queries.CountPendingSuggestions(ctx); err == nil {
        data.PendingSuggestions = pendingSugg
    }

    if recentJobs, err := h.db.Queries.GetRecentJobs(ctx, 5); err == nil {
        data.RecentJobs = recentJobs
    }

    data.ActiveProvider = h.getActiveProvider(ctx)

    if jobsToday, err := h.db.Queries.GetDashboardJobsToday(ctx); err == nil {
        data.JobsToday = jobsToday
    }

    // Sources section
    if sourceStats, err := h.db.Queries.GetDashboardSourceStats(ctx); err == nil {
        data.Inboxes.Total = sourceStats.InboxTotal
        data.Inboxes.Enabled = sourceStats.InboxEnabled
        data.NetworkSources.Total = sourceStats.NetworkTotal
        data.NetworkSources.Enabled = sourceStats.NetworkEnabled
    }

    return admin.Dashboard(data).Render(ctx, c.Response().Writer)
}
```

Note: The template call `admin.Dashboard(data)` will require the template to be updated to accept DashboardData. For now, the handler will compile but template changes are in Plan 03.

Add required imports:
- "context"
- "docko/internal/database/sqlc"
  </action>
  <verify>
Check `./tmp/air-combined.log` for compilation errors.
The handler will compile but template call won't work until Plan 03 updates the template.
Verify struct is defined correctly by searching for DashboardData in the file.
  </verify>
  <done>
DashboardData struct defined with all fields, handler aggregates all stats with graceful error handling, health calculation helper implemented.
  </done>
</task>

</tasks>

<verification>
1. `internal/handler/admin.go` contains DashboardData struct
2. Handler fetches all dashboard stats with error handling
3. calculateQueueHealth function returns correct status
4. No compilation errors (template mismatch expected until Plan 03)
</verification>

<success_criteria>
- DashboardData struct matches CONTEXT.md requirements
- All data sources aggregated in handler
- Graceful degradation on query errors (use defaults, not crash)
</success_criteria>

<output>
After completion, create `.planning/phases/11-dashboard/11-02-SUMMARY.md`
</output>
