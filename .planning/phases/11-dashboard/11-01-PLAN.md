---
phase: 11-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sqlc/queries/dashboard.sql
autonomous: true

must_haves:
  truths:
    - "Dashboard queries return aggregated document stats"
    - "Dashboard queries return queue/processing stats"
    - "Dashboard queries return source stats"
  artifacts:
    - path: "sqlc/queries/dashboard.sql"
      provides: "Dashboard aggregation queries"
      contains: "GetDashboardDocumentStats"
    - path: "internal/database/sqlc/dashboard.sql.go"
      provides: "Generated query methods"
      contains: "GetDashboardDocumentStats"
  key_links:
    - from: "sqlc/queries/dashboard.sql"
      to: "internal/database/sqlc/dashboard.sql.go"
      via: "sqlc generate"
      pattern: "GetDashboard"
---

<objective>
Create sqlc queries for dashboard data aggregation.

Purpose: Efficient single-query data fetching for each dashboard section, avoiding N+1 query problems.
Output: Dashboard queries file with aggregation queries for documents, queues, and sources.
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-dashboard/11-CONTEXT.md
@.planning/phases/11-dashboard/11-RESEARCH.md
@sqlc/queries/documents.sql
@sqlc/queries/jobs.sql
@sqlc/queries/inboxes.sql
@sqlc/queries/network_sources.sql
@sqlc/queries/tags.sql
@sqlc/queries/correspondents.sql
@sqlc/queries/ai.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dashboard aggregation queries</name>
  <files>sqlc/queries/dashboard.sql</files>
  <action>
Create `sqlc/queries/dashboard.sql` with efficient aggregation queries:

1. **GetDashboardDocumentStats** - Single query returning document counts:
   - total: COUNT(*)
   - processed: COUNT(*) FILTER (WHERE processing_status = 'completed')
   - pending: COUNT(*) FILTER (WHERE processing_status = 'pending')
   - failed: COUNT(*) FILTER (WHERE processing_status = 'failed')
   - today: COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE)

   Return type: :one

2. **GetDashboardQueueStats** - Single query returning job counts:
   - pending: COUNT(*) FILTER (WHERE status = 'pending')
   - completed: COUNT(*) FILTER (WHERE status = 'completed')
   - failed: COUNT(*) FILTER (WHERE status = 'failed')
   - processing: COUNT(*) FILTER (WHERE status = 'processing')

   Return type: :one

3. **GetDashboardSourceStats** - Single query using subqueries:
   - inbox_total: (SELECT COUNT(*) FROM inboxes)
   - inbox_enabled: (SELECT COUNT(*) FROM inboxes WHERE enabled = true)
   - network_total: (SELECT COUNT(*) FROM network_sources)
   - network_enabled: (SELECT COUNT(*) FROM network_sources WHERE enabled = true)

   Return type: :one

4. **CountTags** - Simple count query:
   - SELECT COUNT(*) FROM tags;

   Return type: :one

5. **CountCorrespondents** - Simple count query:
   - SELECT COUNT(*) FROM correspondents;

   Return type: :one

6. **GetDashboardJobsToday** - Count jobs processed today:
   - SELECT COUNT(*) FROM jobs WHERE created_at >= CURRENT_DATE

   Return type: :one

Use PostgreSQL FILTER clause for conditional aggregation (more efficient than CASE WHEN).
  </action>
  <verify>
Check `./tmp/air-combined.log` for any sqlc generation errors.
Run: `cat ./tmp/air-combined.log | tail -50`
Verify `internal/database/sqlc/dashboard.sql.go` exists and contains GetDashboardDocumentStats function.
  </verify>
  <done>
All 6 dashboard queries are defined in dashboard.sql, sqlc generates corresponding Go methods without errors.
  </done>
</task>

</tasks>

<verification>
1. `sqlc/queries/dashboard.sql` exists with all aggregation queries
2. `internal/database/sqlc/dashboard.sql.go` generated successfully
3. No sqlc errors in build log
4. Queries use efficient FILTER clauses instead of multiple COUNT queries
</verification>

<success_criteria>
- All 6 dashboard queries defined
- sqlc generates Go code without errors
- Query methods available on Queries struct
</success_criteria>

<output>
After completion, create `.planning/phases/11-dashboard/11-01-SUMMARY.md`
</output>
