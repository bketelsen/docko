---
phase: 02-ingestion
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-02", "02-03", "02-04"]
files_modified:
  - cmd/server/main.go
  - internal/handler/inboxes.go
  - internal/handler/handler.go
  - templates/pages/admin/inboxes.templ
autonomous: false

must_haves:
  truths:
    - "Upload page is accessible at /upload"
    - "Inbox watcher starts automatically on server startup"
    - "User can manage inbox directories via web UI"
    - "Inbox status shows green/red health indicator"
  artifacts:
    - path: "cmd/server/main.go"
      provides: "Wired upload handler and inbox watcher"
      contains: "inbox.New"
    - path: "templates/pages/admin/inboxes.templ"
      provides: "Inbox management UI"
      min_lines: 50
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/inbox/service.go"
      via: "inboxSvc.Start()"
      pattern: "inboxSvc\\.Start"
    - from: "cmd/server/main.go"
      to: "internal/handler/handler.go"
      via: "Handler.New with docSvc"
      pattern: "handler\\.New.*docSvc"
---

<objective>
Wire upload handler and inbox watcher into main.go, create inbox management UI.

Purpose: Complete the ingestion phase by connecting all components and providing inbox configuration UI
Output: Working upload endpoint, running inbox watcher, inbox management page
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-ingestion/02-CONTEXT.md
@.planning/phases/02-ingestion/02-01-SUMMARY.md
@.planning/phases/02-ingestion/02-02-SUMMARY.md
@.planning/phases/02-ingestion/02-03-SUMMARY.md
@.planning/phases/02-ingestion/02-04-SUMMARY.md
@cmd/server/main.go
@internal/handler/handler.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire upload handler and inbox watcher in main.go</name>
  <files>cmd/server/main.go</files>
  <action>
Modify `cmd/server/main.go`:

1. Import inbox package:
```go
import (
    // ... existing imports
    "docko/internal/inbox"
)
```

2. Update Handler.New() call to include document service:
```go
h := handler.New(cfg, db, authService, docSvc)
```

3. Create and start inbox service after document service:
```go
// Create inbox service
inboxSvc := inbox.New(db, docSvc, cfg)

// Start inbox watcher (in goroutine with context)
go func() {
    if err := inboxSvc.Start(ctx); err != nil && err != context.Canceled {
        slog.Error("inbox service error", "error", err)
    }
}()
```

4. Add inbox service to graceful shutdown:
```go
// In shutdown handler:
slog.Info("stopping inbox watcher...")
if err := inboxSvc.Stop(); err != nil {
    slog.Error("failed to stop inbox watcher", "error", err)
}
```

5. Run database migrations (already happens, just ensure it runs before inbox service):
   - Migrations auto-run on DB connection, so inbox table will exist

6. Pass inboxSvc to handler if needed for inbox management routes:
```go
h := handler.New(cfg, db, authService, docSvc, inboxSvc)
```
Or add method to set inbox service after handler creation.
  </action>
  <verify>Check file compiles: `go build ./cmd/server/...` succeeds</verify>
  <done>main.go creates and starts inbox service, passes docSvc to handler</done>
</task>

<task type="auto">
  <name>Task 2: Create inbox management handler</name>
  <files>internal/handler/inboxes.go, internal/handler/handler.go</files>
  <action>
1. Update Handler struct in handler.go to include inbox service:
```go
type Handler struct {
    cfg      *config.Config
    db       *database.DB
    auth     *auth.Service
    docSvc   *document.Service
    inboxSvc *inbox.Service  // Add this
}
```

Update New() constructor and RegisterRoutes() to add inbox routes:
```go
// Inbox management routes (protected)
e.GET("/inboxes", h.InboxesPage, middleware.RequireAuth(h.auth))
e.POST("/inboxes", h.CreateInbox, middleware.RequireAuth(h.auth))
e.PUT("/inboxes/:id", h.UpdateInbox, middleware.RequireAuth(h.auth))
e.DELETE("/inboxes/:id", h.DeleteInbox, middleware.RequireAuth(h.auth))
e.POST("/inboxes/:id/toggle", h.ToggleInbox, middleware.RequireAuth(h.auth))
```

2. Create `internal/handler/inboxes.go`:

```go
package handler

// InboxesPage renders the inbox management page
func (h *Handler) InboxesPage(c echo.Context) error

// CreateInbox creates a new inbox directory
func (h *Handler) CreateInbox(c echo.Context) error

// UpdateInbox updates inbox settings
func (h *Handler) UpdateInbox(c echo.Context) error

// DeleteInbox removes an inbox
func (h *Handler) DeleteInbox(c echo.Context) error

// ToggleInbox enables/disables an inbox
func (h *Handler) ToggleInbox(c echo.Context) error
```

Implementation details:
- InboxesPage: List all inboxes with status (enabled, last scan, last error)
- CreateInbox: Validate path exists and is readable, create in DB, add to watcher
- UpdateInbox: Update name, path, error_path, duplicate_action
- DeleteInbox: Remove from watcher, delete from DB
- ToggleInbox: Toggle enabled flag, add/remove from watcher
- Use HTMX for partial updates where appropriate
  </action>
  <verify>Check file compiles: `go build ./internal/handler/...` succeeds</verify>
  <done>inboxes.go handlers created, handler.go updated with inboxSvc and routes</done>
</task>

<task type="auto">
  <name>Task 3: Create inbox management UI template</name>
  <files>templates/pages/admin/inboxes.templ</files>
  <action>
Create `templates/pages/admin/inboxes.templ`:

Per CONTEXT.md decisions:
- Multiple inbox directories supported
- Individual inboxes can be enabled/disabled via toggle
- Status indicator per inbox (green/red showing accessibility and watcher health)

1. Page layout using admin layout

2. Inbox list with cards:
   - Name and path
   - Status indicator: green dot if enabled and no last_error, red if error or disabled
   - Last scan time (relative, e.g., "2 minutes ago")
   - Last error message (if any)
   - Toggle switch for enabled/disabled
   - Edit and delete buttons

3. Add inbox form:
   - Name input
   - Path input (text, user enters full path)
   - Error path input (optional, defaults to {path}/errors)
   - Duplicate action dropdown (delete, rename, skip)
   - Submit button

4. Inbox detail/edit modal or section:
   - Edit all fields
   - Recent events log (last 10 from inbox_events)
   - Save and Cancel buttons

5. HTMX integration:
   - Toggle switch: hx-post="/inboxes/:id/toggle" hx-swap="outerHTML"
   - Create form: hx-post="/inboxes" hx-target="#inbox-list" hx-swap="beforeend"
   - Delete: hx-delete="/inboxes/:id" hx-confirm="Delete this inbox?" hx-target="closest .inbox-card" hx-swap="outerHTML"

Use Tailwind classes consistent with existing admin pages.
Status indicator: `w-3 h-3 rounded-full bg-green-500` or `bg-red-500`
  </action>
  <verify>Run `make generate` and check template compiles</verify>
  <done>inboxes.templ exists with list, status indicators, toggle, and CRUD forms</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete ingestion system:
- Web upload with drag-and-drop at /upload
- Inbox watcher automatically processing PDFs
- Inbox management UI at /inboxes
  </what-built>
  <how-to-verify>
1. Start the server: `make dev`
2. Visit http://localhost:3000/login and log in

**Test web upload:**
3. Go to http://localhost:3000/upload
4. Drag a PDF file onto the page - overlay should appear
5. Drop the file - progress bar should show, then success
6. Try dragging a non-PDF - should be rejected
7. Try uploading the same PDF again - should show "duplicate" message

**Test inbox watcher:**
8. Go to http://localhost:3000/inboxes
9. Create a new inbox pointing to a test directory (e.g., /tmp/docko-inbox)
10. Create the directory: `mkdir -p /tmp/docko-inbox`
11. Copy a PDF to the inbox: `cp some.pdf /tmp/docko-inbox/`
12. Check that the file is processed (disappears from inbox, appears in documents)
13. Check inbox events show the import

**Test duplicate handling in inbox:**
14. Copy the same PDF to inbox again
15. Should be deleted silently, inbox events show "duplicate"

**Test error handling:**
16. Copy a non-PDF file with .pdf extension to inbox
17. Should be moved to errors/ subdirectory
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `make dev` starts without errors
3. Server log shows "inbox service started" or similar
4. Upload page accessible at /upload
5. Inboxes page accessible at /inboxes
6. Drag-drop upload works with progress
7. Inbox watcher processes files automatically
</verification>

<success_criteria>
- Upload handler wired and accessible at /upload
- Inbox watcher starts on server startup
- Inbox management UI allows CRUD operations
- Status indicators show inbox health
- All five phase success criteria from ROADMAP.md are met:
  1. Drag-and-drop upload works
  2. Bulk upload works
  3. Inbox auto-detects PDFs
  4. Duplicates detected by hash
  5. Duplicate handling configurable per inbox
</success_criteria>

<output>
After completion, create `.planning/phases/02-ingestion/02-05-SUMMARY.md`
</output>
