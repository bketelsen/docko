---
phase: 02-ingestion
plan: 04
type: execute
wave: 2
depends_on: ["02-03"]
files_modified:
  - internal/inbox/watcher.go
  - internal/inbox/service.go
autonomous: true

must_haves:
  truths:
    - "Inbox watcher detects new PDF files near-instantly via fsnotify"
    - "Existing files in inbox are processed on service startup"
    - "Failed files (corrupt, not PDF) are moved to error folder"
    - "Duplicate files are deleted silently with log entry"
  artifacts:
    - path: "internal/inbox/watcher.go"
      provides: "fsnotify-based directory watcher"
      min_lines: 100
    - path: "internal/inbox/service.go"
      provides: "Inbox service coordinating watcher and document ingestion"
      exports: ["Service", "New", "Start", "Stop"]
  key_links:
    - from: "internal/inbox/watcher.go"
      to: "internal/document/document.go"
      via: "docSvc.Ingest() call"
      pattern: "docSvc\\.Ingest"
    - from: "internal/inbox/watcher.go"
      to: "github.com/fsnotify/fsnotify"
      via: "fsnotify.NewWatcher()"
      pattern: "fsnotify\\.NewWatcher"
---

<objective>
Create inbox watcher service using fsnotify for near-instant file detection with proper debouncing and error handling.

Purpose: Enable automated document ingestion from local directories per CONTEXT.md decisions
Output: Inbox service that watches directories, processes PDFs, handles duplicates, and moves failures to error folder
</objective>

<execution_context>
@/home/bjk/.claude/get-shit-done/workflows/execute-plan.md
@/home/bjk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-ingestion/02-CONTEXT.md
@.planning/phases/02-ingestion/02-RESEARCH.md
@.planning/phases/02-ingestion/02-03-SUMMARY.md
@internal/document/document.go
@internal/database/sqlc/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inbox watcher with fsnotify and debouncing</name>
  <files>internal/inbox/watcher.go</files>
  <action>
Create `internal/inbox/watcher.go`:

1. Debouncer struct (per RESEARCH.md Pitfall 1):
```go
type debouncer struct {
    timers map[string]*time.Timer
    mu     sync.Mutex
}

func newDebouncer() *debouncer
func (d *debouncer) Debounce(path string, delay time.Duration, fn func())
func (d *debouncer) Cancel(path string)
```

2. Watcher struct:
```go
type Watcher struct {
    watcher   *fsnotify.Watcher
    debouncer *debouncer
    handler   func(path string)  // Called for each stable file
    delay     time.Duration      // Debounce delay (default 500ms)
}

func NewWatcher(delay time.Duration, handler func(string)) (*Watcher, error)
func (w *Watcher) Add(path string) error
func (w *Watcher) Remove(path string) error
func (w *Watcher) Run(ctx context.Context) error
func (w *Watcher) Close() error
```

3. Run() implementation:
   - Select on watcher.Events, watcher.Errors, and ctx.Done()
   - On Create or Write event: debounce with delay, then call handler
   - On Errors: log with slog.Error
   - On ctx.Done(): return ctx.Err()

4. Debounce behavior:
   - Each file path gets its own timer
   - New events reset the timer
   - Handler called only after no events for `delay` duration
   - This handles large files being written in chunks (multiple Write events)

Key implementation notes from RESEARCH.md:
- Use Create AND Write events (some editors use atomic renames)
- Debounce delay of 500ms handles most write patterns
- Handler should be goroutine-safe (may be called concurrently)
  </action>
  <verify>Check file compiles: `go build ./internal/inbox/...` succeeds</verify>
  <done>watcher.go implements fsnotify watcher with debouncing</done>
</task>

<task type="auto">
  <name>Task 2: Create inbox service coordinating watcher and ingestion</name>
  <files>internal/inbox/service.go</files>
  <action>
Create `internal/inbox/service.go`:

1. Service struct:
```go
type Service struct {
    db        *database.DB
    docSvc    *document.Service
    cfg       *config.Config
    watcher   *Watcher
    mu        sync.RWMutex
    watching  map[uuid.UUID]string  // inbox ID -> path
    semaphore chan struct{}         // Limit concurrent ingestions
}

func New(db *database.DB, docSvc *document.Service, cfg *config.Config) *Service
func (s *Service) Start(ctx context.Context) error
func (s *Service) Stop() error
func (s *Service) AddInbox(inbox *sqlc.Inbox) error
func (s *Service) RemoveInbox(inboxID uuid.UUID) error
func (s *Service) RefreshInboxes(ctx context.Context) error
```

2. Start() implementation:
   - Create watcher with file handler
   - Load enabled inboxes from database
   - If cfg.Inbox.DefaultPath set and no inbox exists with that path, create default inbox
   - Scan each inbox directory for existing files (per RESEARCH.md Pitfall 5)
   - Start watcher in goroutine
   - Use semaphore to limit concurrent ingestions (default 4)

3. File handler (called by watcher):
   - Validate PDF using h2non/filetype magic bytes
   - If not PDF: move to inbox error path, log inbox_events
   - Call docSvc.Ingest()
   - If duplicate: delete file silently, log inbox_events with action="duplicate"
   - If success: delete original file, log inbox_events with action="imported"
   - If error: move to error path, log inbox_events with action="error"
   - Update inbox last_scan_at and last_error

4. Scan existing files on startup:
```go
func (s *Service) scanDirectory(ctx context.Context, inbox *sqlc.Inbox) error {
    entries, err := os.ReadDir(inbox.Path)
    // ... for each .pdf file, process it
}
```

5. Error handling:
   - Move failed files to error_path (default: {inbox_path}/errors/)
   - Create error directory if not exists
   - Rename format: {original}_{timestamp}.pdf to avoid collisions

Per CONTEXT.md decisions:
- Delete inbox files after successful import
- Delete silently on duplicate, log occurrence
- Move failed files to error folder (inbox/errors/)
- Process existing files on startup
  </action>
  <verify>Check file compiles: `go build ./internal/inbox/...` succeeds</verify>
  <done>service.go coordinates watcher, document service, and inbox configuration</done>
</task>

</tasks>

<verification>
1. `go build ./internal/inbox/...` succeeds
2. Watcher uses fsnotify: `grep "fsnotify" internal/inbox/watcher.go`
3. Service uses debouncing: `grep "Debounce" internal/inbox/watcher.go`
4. Service handles duplicates: `grep "duplicate" internal/inbox/service.go`
5. Service scans on startup: `grep "scanDirectory\|ReadDir" internal/inbox/service.go`
</verification>

<success_criteria>
- Watcher detects files via fsnotify with 500ms debounce
- Service processes existing files on startup
- PDF validation via magic bytes before ingestion
- Duplicates deleted silently with inbox_events log entry
- Failed files moved to error subdirectory
- Concurrent ingestions limited by semaphore (4 workers)
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-ingestion/02-04-SUMMARY.md`
</output>
